//AHB example taken from Synthesis of Reactive(1) Designs 2 masters
range Bool = 0..1
range T_range = 0..2
set Global_Alphabet = {}
set Controllable_Alphabet = {}

set Global_Signals	= {hMastLock, hBurst_0, hBurst_1, t_0, t_1, start}
set Output_Signals	= {hMastLock, hBurst_0, hBurst_1, t_0, t_1}
order			= {}

/***********
**** THETA
***********/
ltl env theta Init_AHB_e in AHB	= (start).
ltl sys theta Init_AHB_s in AHB	= (hGrant_0 && !hBurst_0 && !hBurst_1 && start && !t_0 && !t_1).
/***********
**** SYS RHO
***********/
//G2: when a locked unspecified length burst starts, a new access does not start until the current master releases the bus by lowering hBusReq[hMaster]
ltl sys rho G_2_t00_t00 in AHB	= []((!t_0 && !t_1 && !(hMastLock && !hBurst_0 && hBurst_1 && start))-> X(!t_0 && !t_1)).
ltl sys rho G_2_t00_t01 in AHB	= []((!t_0 && !t_1 && hMastLock && !hBurst_0 && hBurst_1 && start)-> X(t_0 && !t_1)).
ltl sys rho G_2_t01_t01 in AHB	= []((t_0 && !t_1 && busReq && !start)-> X(t_0 && !t_1)).
ltl sys rho G_2_t01_t00 in AHB	= []((t_0 && !t_1 && !busReq && !start)-> X(!t_0 && !t_1)).
ltl sys rho G_2_t01_t10 in AHB	= []((t_0 && !t_1 && start)-> X(!t_0 && t_1)).
ltl sys rho G_2_t10_t10 in AHB	= []((!t_0 && t_1)-> X(!t_0 && t_1)).

ltl env rho E_1 in AHB = [](start || !start).


ltl env theta Init_AHB_e in AHB_b	= (start).
ltl sys theta Init_AHB_s in AHB_b	= (hGrant_0 && !hBurst_0 && !hBurst_1 && start && !t_0 && !t_1).
/***********
**** SYS RHO
***********/
//G2: when a locked unspecified length burst starts, a new access does not start until the current master releases the bus by lowering hBusReq[hMaster]
ltl sys rho G_2_t00_t00 in AHB_b	= [](!t_0 || t_0).
ltl env rho E_1 in AHB_b = [](start || !start).

//0->0 (!t_0 && !t_1 && !(hMastLock && !hBurst_0 && hBurst_1 && start))-> X(!t_0 && !t_1)).
//0->1 (!t_0 && !t_1 && hMastLock && !hBurst_0 && hBurst_1 && start)-> X(t_0 && !t_1).
RESTRICT = R[0][0][0][0][0],
R[t:T_range][mLock:Bool][hB_0:Bool][hB_1:Bool][s:Bool] = (
	when ((t == 0) * )  
	).
	
	//Concrete
MAZE = M[1][1],
M[r:Pos][c:Pos] = ( 
				when(r > Min) n->M[r-1][c] 
				| when(r < Max) s->M[r+1][c]
				| when(c > Min) w->M[r][c-1]
				| when(c < Max) e->M[r][c+1]
				| when((r == Max) * (c == Max)) load->M[r][c]
				| when((r == Min) * (c == Min)) unload->M[r][c]
				| when(r == c) stall -> M[r][c]
).