When writing a specification or an abstraction of a digital system it is convenient to describe its behavior with game structures. This formalism captures the semantic of a two player game where the first participant, the environment, observes the state of both input and output variables at a given point of time to define a new valuation for the input, only then the second player, the system, observes both the previous and the current partial states to define the new valuation for the output. 

The set of possible actions for each player is described as relations between current and next (primed) state's variables. Satisfaction of $\gsRhoE: \gsX \times \gsY \times \gsX'$ describes the values that $\gsX'$ can take when $\gsX$ and $\gsY$ are fixed. Both the initial conditions and the transition relations can be described as boolean formulas which in turn can be represented with OBDDs. OBDDs can be composed, restricted over a subset of known values, checked for satisfiability and equality among other operations. Algorithms that work with OBDDs can and do process sets of states at each step, but finite state machines, such as CLTS, can only be processed one state at a time.

\begin{definition}
	\label{def:GS} \emph{(Game Structures)} 
	A \emph{Game Structure} (GS) $G =  \langle \gsV, \gsX, \gsY, \gsTheE, \gsTheS, \gsRhoE, \gsRhoS, \varphi \rangle$ consists of the following:
	\begin{itemize}
		\item $\gsV = \{v_1,\ldots,v_n\}$ : A finite set of typed state variables over finite domains, without loss of generality we assume that they are all Boolean. In the context of a game structure a state is defined as an assignment of $\gsV$, $s \in \Sigma_{\gsV}$.
		\item $\gsX \subseteq \gsV$ is a set of input variables.
		\item $\gsY = \gsV \setminus \gsX$ is a set of output variables.
		\item $\gsTheE$ is an assertion over $\gsX$ characterizing the initial states of the environment.
		\item $\gsTheS$ is an assertion over $\gsV$ characterizing the initial states of the system.		
		\item $\gsRhoE(\gsV,\gsX')$ is the transition relation of the environment, it identifies a valuation $s_{\gsX} \in \Sigma_{\gsX}$ as a possible input in state $s$ if $(s,s_{\gsX}) \models \gsRhoE$.
		\item $\gsRhoS(\gsV,\gsX',\gsY')$ is the transition relation of the system, it identifies a valuation $s_{\gsY} \in \Sigma_{\gsY}$ as a possible output in state $s$ reading input $s_{\gsX} $if $(s,s_{\gsX}, s_{\gsY}) \models \gsRhoS$.		
		\item $\varphi$ is the winning condition, given by an LTL formula.
	\end{itemize} 
\end{definition}

\begin{definition}
	\label{def:GS_play} \emph{(Play over Game Structure)} 
	Let $G =  \langle \gsV, \gsX, \gsY, \gsTheE, \gsTheS, \gsRhoE, \gsRhoS, \varphi \rangle$ be a game structure, $\sigma = \sigma_1,\sigma_2,\ldots \in (2^{\mathcal{V}})^\omega$ is a play over $G$ if the following holds:
	\begin{itemize} 
		\item The initial condition is satisfied, i.e. $\theta_e(\sigma_1|_{\mathcal{X}}) \wedge \theta_s(\sigma_1)$
		\item The valuations are updated according to $\rho$,
		 $\forall i \in 2\ldots: \rho_e(\sigma_{i-1}, \sigma_i|_{\mathcal{X}}) \wedge \rho_s(\sigma_{i-1}, \sigma_i|_{\mathcal{X}},\sigma_i|_{\mathcal{Y}})$		
	\end{itemize}
\end{definition}

A play $\sigma$ satisfies LTL formula $\varphi$  if $\sigma_1 \models \varphi$ according to the following inductive definition:

\begin{tabular}{ l c l }
	$\sigma_i \models_d v$ & $\triangleq$ & $v \in \sigma_i$ for any $v \in \mathcal{V}$\\	
	$\sigma_i \models_d \neg \varphi$ & $\triangleq$ & $\sigma_i \not\models_d \varphi$\\
	$\sigma_i \models_d \varphi \vee \psi$ & $\triangleq$ & $(\sigma_i \models_d \varphi) \vee (\sigma_i \models_d \psi)$\\
	$\sigma_i \models_d \bigcirc \varphi$ & $\triangleq$ & $\sigma_{i+1} \models_d \varphi$\\
	$\sigma_i \models_d \varphi \U \psi$ & $\triangleq$ & $\exists j \geq i . \sigma_j \models_d \psi \wedge \forall i \leq k \le k. \sigma_k \models_d \varphi$\\
\end{tabular}

A game structure $G$ satisfies LTL formula $\varphi$ if it is satisfied by all of its plays.

Many non trivial digital designs require the definition of state machines to some extent or another, while at the same time high level specifications can involve interactions with digital or truly concurrent components. Under these circumstances a mixed specification over both a finite state process algebra and a LTL game structure definition is desirable.  In order to reason about their composed behavior a proper common representation is needed. Our approach is to transform the game structure into its equivalent finite state automaton and then compose both using one of the parallel composition semantics.

\textcolor{blue}{We now present} the background required to relate the model checking approach in game structures to an equivalent control problem in the CLTS domain.  The main idea behind this is that any game structure specified as a set of LTL formulas induces an equivalent automaton. A pair of translations from a set of LTL formulas to a Kripke structure and from a Kripke structure to a CLTS are introduced first and then a direct transformation between a set of LTL formulas and a CLTS structure.

\begin{definition}
	\label{def:Kripke} \emph{(Kripke Structures)} 
	Let $AP$ be a set of atomic propositions, a \emph{Kripke Structure} (KS)  $K$ over $AP$ is a tuple $K =  \langle S, I, R, L \rangle$ consisting of the following:
	\begin{itemize}
		\item $S$ a finite set of states
		\item $I \subseteq$ a set of initial states
		\item $R \subseteq S \times S$ a transition relation
		\item $L: S \rightarrow 2^{AP}$ a labeling function
	\end{itemize} 
\end{definition}

The translation between game structures and Kripke interprets valuations as states, and relations between those as transitions. Let $G$ be the game structure to be translated and $K=\langle S, I, R, L \rangle$ the target Kripke structure over $AP$. 
Assume that $|AP|=|\mathcal{V}|$ and that for each $v_i \in \mathcal{V}$ exists a proposition $\cdot(v_i) \in AP$. Valuations over $AP$ in $G$ are mapped to states in $S$ as follows, given a valuation $v \in \mathcal{V}$, $\cdot(v)$ represents a unique state in $S$ such that  $|L(\cdot(v))| = |v|$ and for each $v_i \in v$ it holds $\cdot(v_i) \in L(\cdot(v))$. The translation starts with $K$ having an initial state $s_0$ with no valuation associated to it. For every $x \in 2^{|X|}$ where $\theta_e(x)$ holds, a new state $\cdot(x)$ and transition $(s_0, \cdot(x))$ are added to $K$, then for each $x \in 2^{|X|}$, $y \in 2^{|Y|}$ such that $\theta_e(x)$ and $\theta_s(x \cup y)$ hold, state $\cdot(x \cup y)$ and transition $(\cdot(x), \cdot(x \cup y)$ are added to $K$.  For every $v,x' \in 2^{|V|\times|X'|}$ satisfying $\rho_e(v,x')$, a new state $\cdot(v \cup x')$ and transition $(\cdot(v), \cdot(v\cup x'))$ are added to $K$, and for each valuation $v,x',y' \in 2^{|V|\times|X'|\times|Y'|}, $ satisfying $\rho_e(v, x')$ and $\rho_s(v,x',y')$, state $\cdot(x \cup y)$ and transition $(\cdot(v \cup x'), \cdot(x \cup y))$ are added to $K$. 
If the Kripke structure is constructed according to the previous translation, the following properties hold, describing the relation between plays over $G$ and paths over $K$:
	\[\begin{aligned}[t]
	\forall x, y: \theta_e(x) \wedge \theta_s(x,y)& \implies\\
	&(s_0, \cdot (x)), (\cdot(x), \cdot (x \cup y)) \in R \\
	&\wedge \forall x_i \in x: \cdot(x_i) \in L(\cdot(x)) \wedge \forall v_i \in x \cup y : \cdot(v_i) \in L(\cdot(x \cup y))\\
	\forall x, y : \exists v \rho_e(v,x) \wedge \rho_s(v,x,y)& \implies\\
	&(\cdot(v), \cdot(v \cup x)), (\cdot(v \cup x),\cdot(x \cup y)) \in R\\
	&\wedge \forall v_i \in v: \cdot(v_i) \in L(\cdot(v)) \\
	&\wedge \forall w_i \in v \cup x: \cdot(w_i) \in L(\cdot(v \cup x))\\
	&\wedge \forall z_i \in x \cup y: \cdot(z_i) \in L(\cdot(x \cup y))	
	\end{aligned}
	\] 

A translation between LTL formulas over atomic propositions in $K$ and boolean variables in $G$ is straight forward, since the only consideration to be taken is regarding the atomic case of formula $\varphi$ (consisting of a single variable $v_i$). Suppose that $\cdot(\varphi)$ is the translation from boolean variables into atomic propositions, we say that $\varphi$ is satisfied in a play $\sigma=s_0s_1\ldots s_i$ over $G$ if $v_i \in s_i$. In our case this also implies that $\cdot(\varphi)$ is satisfied in the path $\rho=\cdot(s_0)\cdot(s_1)\ldots \cdot(s_i)$ over $K$, since $\cdot(v_i)$ appears in $L(\cdot(s_i))$. It follows from this observation, that if $K$ is the Kripke structure constructed from $G$ following the previous translation, then LTL satisfaction is preserved between structures.

The second step of our composed translation is to transform $K$ into a CLTS instance $M$.
The set of states is kept as is and the labels are moved from $L$ in $K$ to $\Delta$ in $M$. If $M=\langle S, \Sigma, \Delta, s_0 \rangle$ is constructed fom $K =\langle S,I,R,L \rangle$ over $AP$, then both state sets are equal, $s_0$ is the only element in $I$, (since it was, in turn, constructed from $G$) and both $\Sigma$ and $\Delta$ are defined as follows:

\[\forall a \in AP: a\uparrow \in \Sigma \wedge a\downarrow \in \Sigma \]
\[\forall (s, s') \in R: (s, \delta(s,s'), s') \in \Delta \]

Where we add labels to the transitions in $\Delta$, indicating the change of individual variables between valuations. If a variable keeps its value then it will not take part in the transition, otherwise if, for instance, variable $v$ is present in $s$ but not in $s'$, the change is made explicit by adding $v\downarrow$ to the concurrent label.

\[\delta(s,s'): \lbrace label(a,s,s') | a \in L(s) \neq a \in L(s') \rbrace\]
\[
label (a,s,s') = \begin{cases}
a\uparrow & \text{if } a \in L(s') \\
a\downarrow & \text{if } a \in L(s)
\end{cases}
\]

Now if $\cdot(\varphi)$ is the translation from atomic propositions into fluents, and a set of fluents $\mathcal{F}$ exists containing, for each proposition $a$ a fluent $\langle a\uparrow, a\downarrow \rangle$, we say that, again observing only the atomic case where the formula consists of a single variable, $\varphi$ is satisfied in a path $\rho=s_0 s_1\ldots s_i$ over $K$ if $v_i$ appears in $L(s_i)$. In our case this also implies that $\cdot(\varphi)$ is satisfied in the path $\pi=\cdot(s_0)\cdot(s_1)\ldots \cdot(s_i)$ over $M$ since, from $v_i \in L(s_i)$ follows that at some point the proposition started appearing in states leading to $s_i$, suppose that $s_j$ was the first state were $v_i$ appeared and was kept until reaching $s_i$ ($\forall j \leq k \leq i: v_i \in L(s_k)$), then transition $(s_{j-1},s_j) \in R$ was translated as $(s_{j-1}, \delta(s_{j-1},s_j),s_j)$ and $v_i\uparrow \in \delta(s_{j-1},s_j)$ since its value changed from one state to the other. It follows from this observation, that if $M$ is the CLTS structure constructed from $K$ following the previous translation, then LTL satisfaction is preserved between structures.

Now we can introduce a direct translation between game structures and CLTS instances.

\begin{definition}
	\label{def:fl_ltl} \emph{(LTL over $\mathcal{V}$ to LTL over $\mathcal{F}$ translation)} 
	Let $\varphi$ be a LTL formula over countable boolean variables $\mathcal{V}$, and if $\mathcal{F}$ is the minimal fluent set containing $v_f = \langle v\uparrow, v\downarrow \rangle$ for each $v \in \mathcal{V}$, $fl(\varphi)$ is an equivalent LTL formula over fluents according to the following inductive definition:\\
	
\begin{tabular}{ l c l }
	$fl(v)$ & $\triangleq$ & $v_f$\\	
	$fl(\neg \varphi)$ & $\triangleq$ & $\neg fl(\varphi)$\\
	$fl(\varphi \vee \psi$ & $\triangleq$ & $fl(\varphi) \vee fl(\psi)$\\
	$fl(\bigcirc \varphi)$ & $\triangleq$ & $\bigcirc\bigcirc fl(\varphi)$\\
	$fl(\varphi \U \psi)$ & $\triangleq$ & $fl(\varphi) \U fl(\psi)$\\
\end{tabular}	
\end{definition}


\begin{definition}
	\label{def:gs_to_clts_translation} \emph{(Game Structure to CLTS translation)} 
Let $G =  \langle \gsV, \gsX, \gsY, \gsTheE, \gsTheS, \gsRhoE, \gsRhoS, \varphi \rangle$ be a game structure, $clts(G)=M$ is a CLTS instance such that $G \models \varphi$ $\iff$ $M \models fl(\varphi)$.
\end{definition}

Let $G$ be the game structure to be translated and $M=\langle S, \Sigma, \Delta, s_0 \rangle$ the target CLTS, i.e. the candidate for $clts(G)$. 
$S$ is $2^{|\mathcal{X}|}+2^{|\mathcal{V}|+|\mathcal{X}|}+2^{|\mathcal{V}|}+1$.
The alphabet is defined as the minimal set satisfying 
$\forall v \in \mathcal{V}: v\uparrow \in \Sigma, v\downarrow \in \Sigma$. 
In order to construct $\Delta$ variables will be mapped as following:

\[
\delta(v_i,v) = \begin{cases}
v_i\uparrow & \text{if } v \in v \\
v_i\downarrow & \text{if } v \not\in v
\end{cases}
\]
\[\hat{\delta}(v,v') = \lbrace \delta(v_i,v') | v_i \in v \neq v_i \in v' \rbrace \]
We will use the following set of mappings relating a valuation over those set of variables with a distinct state in the CLTS automaton:
\[s_{\theta_e}:2^{|\mathcal{X}|}\rightarrow S\]
\[s_{\rho_e}:2^{|\mathcal{V}|} \rightarrow S\]
\[s_{\rho_s}:2^{|\mathcal{V}| + |\mathcal{X}|}\rightarrow S\]
Since in the CLTS model we can define only one initial state, the set of initial valuations have to be explicitly reached from the distinguished element $s_0$ through $s_{\theta_e}$ and $s_{\rho_s}$. States reached via $\rho_e$ and $\rho_s$, which updated the environmental variables first and then the system part are mapped through $s_{\rho_e}$ and $s_{\rho_s}$.  The images of these functions do not overlap. 
$\Delta$ is the minimal relation satisfying:
	\[
	\forall x, y: \theta_e(x) \wedge \theta_s(x,y) \implies s_{\theta_e}(x),s_{\rho_s}(x \wedge y) : (s_0, \hat{\delta} (\emptyset, x), s_{\theta_e}(x)), (s_{\theta_e}(x), \hat{\delta} (x,(x \wedge y)), s_{\rho_s}(x \wedge y)) \in \Delta 
	\] 
	\[
	\forall v, x', y': \rho_e(v,x') \wedge \rho_s(v,x',y') \implies\]
	\[(s_{\rho_s}(v), \hat{\delta} (v, v [v \cap \mathcal{X} \mapsto x']),s_{\rho_e}(v \wedge x')), (s_{\rho_e}(v \wedge x'), \hat{\delta} (v[v \cap \mathcal{X}  \mapsto x'],x' \wedge y'), s_{\rho_s}(x' \wedge y')) \in \Delta 
	\] 

As in the previous cases, and showing only the atomic case where the formula consists of a single variable $v$, $\varphi$ is satisfied in move $\sigma_i$ within play $\sigma=\sigma_1,\sigma_2\ldots ,\sigma_i$ on $G$ if $v$ belongs to $\sigma_i$. In our case this also implies that $fl(\varphi)$ is satisfied in state $s_i$ within the path $\pi=s_{\theta_e}(x),s_{\rho_s}(x,y),\ldots,s_i=s_{\rho_*}(\sigma_i)$ over $M$ since, from $v \in \sigma_i$ follows that at some point the proposition started appearing in states leading to $s_i$, (we can assume w.l.o.g. $*$ is either $e$ or $s$ and $\overline{*}$ is its complement, $s$ if $*$ is $e$, and $e$ otherwise), suppose that $s_j$ was the first state were $v$ appeared and was kept until reaching $s_i$ ($\forall j \leq k \leq i: v \in \sigma_k$), then step $(\sigma_{j-1},\sigma_j) \in G$ was translated as $(s_{\rho_*}(\sigma_{j-1}), \hat{\delta}(\sigma_{j-1},s_{\rho_{\overline{*}}}(\sigma_j)),\sigma_{j})$ and $v\uparrow \in \hat{\delta}(\sigma_{j-1},\sigma_j)$ since its value changed from one state to the other. It follows from this observation, that if $M$ is the CLTS structure constructed from $G$ following the previous translation, then LTL satisfaction is preserved between structures.
%
%\begin{definition}
%	\label{def:mixed_env} \emph{(Mixed Environment Definition)} 
%	A mixed environment $D = \langle E, G \rangle$ is defined over both CTLS instances and game structures as follows,
%	let $E_1,\ldots,E_n$ be a set of CLTS automata and $G_1,\ldots,G_m$ a set of game structures,
%	then each component is defined as $G=\langle \mathcal{V}, \mathcal{X}, \cap_{i \in 1..m}\theta_{e_i}, \cap_{i \in 1..m}\theta_{s_i},$ $\cap_{i \in 1..m}\rho_{e_i},$ $\cap_{i \in 1..m}\rho_{s_i}\rangle$ and $E = \parallel_{*,i \in 1..n} E_i$, where $\parallel_*$ stands for either the asynchronous or synchronous composition semantic.
%	The composed behavior of $D$ is defined by the automaton $E \parallel_* clts(G)$, thus $\langle E, G \rangle \models \varphi$ means $(E \parallel_* clts(G)) \models \varphi$.
%\end{definition}
%
%
%\begin{definition}
%	\label{def:mixed_control_problem} \emph{(Mixed Control Problem)} 
%	Let $D= \langle E, G \rangle$ be a mixed environment, if $\mathcal{F}$ is a set of fluents over $\Sigma$ and $\varphi$ an LTL formula over $\mathcal{F}$, then $I = \langle E, G, \mathcal{F}, \varphi \rangle$ conforms a mixed control problem. If $I$ is consistent and a solution to $I$ exists, such a solution will be a CLTS $M$, legal w.r.t. $D$, such that, $D \parallel M \models \varphi$.
%\end{definition}
%
%\begin{definition}
%	\label{def:consistent_mixed_control_problem} \emph{(Consistent Mixed Control Problem)} 
%	Let $I = \langle E, G, \mathcal{F}, \varphi \rangle$ be a mixed control problem, $I$ is consistent if $\forall v \in \mathcal{V}: v\uparrow, v\downarrow \in \Sigma$, let
%	$\mathcal{Y} = \mathcal{V}\setminus \mathcal{X}$, $v \in \mathcal{Y}$ implies $v\uparrow, v\downarrow \in \mathcal{C}$, $\dot{v} = \lbrace v\uparrow, v\downarrow \rbrace \in \mathcal{F}$ and both $E$ and $clts(G)$ are consistent w.r.t. $\mathcal{F}$.
%\end{definition}


We can now introduce algorithm ~\ref{fig:gs_to_clts_algorithm}, that takes a game structure, represented as a set 
$\gsTheE$, $\gsTheS$, $\gsRhoE$, $\gsRhoS$, $\varphi$ of OBDDs, one for each formula, and produces the CLTS automaton $A$ that preserves its behavior. Since the state space is finite ($2^{|\gsV|}$ at most) and the number of states reached by applying $\gsRhoS(\gsRhoE(v))$ increases monotonically (when starting from $\gsTheS(\gsTheE)$), a least fixed point exists, the algorithm computes such fixed point while progressively creating the transition relation $\Delta$. \texttt{valuations}($\psi$) gives the set of valuations over $\gsV$ for a formula $\psi$ represented with an OBDD. Each valuation induces a unique state in $A$. \texttt{restrict}($\psi$, $s$) fixes a subset of variables in $\psi$ according to $s$ a valuation. If $\varphi$ is the set of propositional formulas involved in the winning condition, \texttt{evaluate\_condition}($A$, $\varphi$, $s$) evaluates the satisfaction of each such formulas according to valuation $s$ and maps the result to $s$ as a state in $A$.
\newpage
\input{gs_to_clts_code}

\newpage
%%%%% CLTS 2 GS


We introduce now a translation from CLTS to game structures.
The first thing that will be addressed is the relation between fluent valuations and states in any given CLTS model. Assume $E = \langle S_E, \Sigma_E, \Delta_E, s^E_0 \rangle$ is the automaton that represents the plant, and $\mathcal{F}=\{fl_1,\ldots,fl_k\}$ with $fl_i = \langle I_i, T_i, init_i \rangle$ the set of fluents associated with a control problem. We will construct a new plant that is compatible with the valuation of the fluents at each step of the execution. To do this we construct an equivalent automaton for each fluent, compose them with each other and with the original plant $E$. This way we have a consistent mechanism to define the set of states satisfying any given fluent.  The for $fl_i$ the candidate fluent automaton is constructed as follows:
\[ FL_i = \langle S_{fl_i}, \Sigma_{fl_i}, \Delta_{fl_i}, s_{0_i}\rangle \]
Where:
\[S_{fl_i}= \{s^{\bot}_i, s^{\top}_i\} \]
\[\Delta_{fl_i} \text{is the minimal relation s.t.}\]
\[ \forall \alpha \in I_i: \{(s^{\bot}_i,\alpha,s^{\top}_i), (s^{\top}_i,\alpha,s^{\top}_i)\} \in \Delta_{fl_i} \]
\[ \forall \beta \in T_i: \{(s^{\top}_i,\beta,s^{\bot}_i), (s^{\bot}_i,\beta,s^{\bot}_i)\} \in \Delta_{fl_i} \]
\[
s_{0_i} = \begin{cases}
s^{\top}_i & init_i = \top \\
s^{\bot}_i & otherwise
\end{cases}
\]

The fluent compatible plant $E_G$ is the result of the synchronous parallel composition of the fluent automata with the original plant:
\[E_G = (E \parallel_s FL_1 ||_s \ldots ||_s FL_k) \]
And the function that determines which states satisfy which fluent is defined as:
\[ fl(i) = \{s \in S_{E_G} : s_{(i + 1)} = s^{\top}_i \} \]
Atomic satisfaction of LTL formula $fl_i$ at step $j$ of trace $\pi$ can be redefined as:
\[ \pi_j \models fl_i \]
Now we introduce the CLTS to Game Structure translation.
\begin{definition}
	\label{def:val_ltl} \emph{(LTL over $\mathcal{F}$ to LTL over $\mathcal{V}$ translation)} 
	Let $\varphi$ be a LTL formula over fluents $\mathcal{F}$, and if $\mathcal{V}$ is the minimal set of boolean variables containing $v_{fl_i}$ for each $f \in \mathcal{F}$, $val(\varphi)$ is an equivalent LTL formula over boolean variables according to the following inductive definition:\\
	
	\begin{tabular}{ l c l }
		$val(fl_i)$ & $\triangleq$ & $v_{fl_i}$\\	
		$val(\neg \varphi)$ & $\triangleq$ & $\neg val(\varphi)$\\
		$val(\varphi \vee \psi$ & $\triangleq$ & $val(\varphi) \vee val(\psi)$\\
		$val(\bigcirc \varphi)$ & $\triangleq$ & $\bigcirc val(\varphi)$\\
		$val(\varphi \U \psi)$ & $\triangleq$ & $val(\varphi) \U val(\psi)$\\
	\end{tabular}	
\end{definition}

\begin{definition}
	\label{def:clts_to_gs_translation} \emph{(CLTS to Game Structure translation)} 
	Let $A = \langle S_A, \Sigma_A, \Delta_A, s_{0_A} \rangle$ be a clts, and $\mathcal{C}\subseteq \Sigma_A$ its controllable alphabet, $gs(A,\mathcal{C})=B$ is a game structure such that $A \models \varphi$ $\iff$ $B \models val(\varphi)$.
\end{definition}

Let $A$ be the CLTS to be translated and $B =  \langle \gsX, \gsY, \gsTheE, \gsTheS, \gsRhoE, \gsRhoS, \varphi \rangle$ the game structure resulting after applying $gs(A)$. 

Let $G$ be the game structure to be translated and $M=\langle S, \Sigma, \Delta, s_0 \rangle$ the target CLTS, i.e. the candidate for $clts(G)$.  We now define the alphabet of the Game Structure as the two sets:
\[\gsX = \{x_i : a_i \in \Sigma_A \setminus \mathcal{C} \}\]
\[\gsY = \{y_i : a_i \in \mathcal{C} \} \cup \{s_i : i \in 1..\lfloor log_2(|S_A|)\rfloor \} \cup \{v_{fl_i} : fl_i \in \mathcal{F}\}\]
From now on we will write $s(j)$ to represent the valuation of the system variables representing a given state $j$, i.e.: 
\[s(j) = \bigwedge\limits^{\lfloor log_2(|S_A|)\rfloor - 1}_{i=0}  s_{bit}(i,j)\]
\[
s_{bit}(i,j) = \begin{cases}
s_i & j / 2^i \\
\neg s_i & otherwise
\end{cases}
\]
To represent the value of fluent $f$ at state $i$ we will use $f_{val}(f,i)$:
\[
f_{val}(f,i) = \begin{cases}
v_{fl_i} & s_i \in fl(f) \\
\neg v_{fl_i} & otherwise
\end{cases}
\]
The initial condition will be set as:
\[\gsTheE = \bigwedge_{i = 1}^{|\Sigma_A \setminus \mathcal{C}|}\neg x_i\]
\[\gsTheS = (\bigwedge_{i = 1}^{|\mathcal{C}|}\neg y_i) \wedge s(0) \wedge (\bigwedge_{f = 1}^{|\mathcal{F}|}f_{val}(f,0))\]
Transition relations are constructed as a conjunction of safety formulae that are added for each state. These can be split into two types, enabling and state updating formulae. The first type restrict the set of variables that can be set to $true$ in a mutually exclusive fashion at each state. The second type defines the state reached for each combination of current state and enabled variables. 
We will use the following two functions to build the conjunction of system or environment variables related to the label in any given automaton transition:
\[\delta_e(l) = \{\bigwedge_{\sigma_i \in \Sigma \setminus \mathcal{C}}var(l, \sigma_i)\}\]
\[\delta_s(l) = \{\bigwedge_{\sigma_i \in \Sigma}var(l, \sigma_i)\}\]
\[
var(l, \sigma_i) = \begin{cases}
\sigma_i & \sigma_i \in l \\
\neg \sigma_i & otherwise
\end{cases}
\]
And the mutually exclusive condition needed for any given state $s_i$ will be described as:
\[mux_e(s_i,L) = s(i) \wedge \bigvee_{l \in L}(\delta_e(l) \wedge \bigwedge_{l' \in L \setminus \{l\}}(\neg \delta_e(l')) ) \]
\[mux_s(s_i,L) = s(i) \wedge \bigvee_{l \in L}(\delta_s(l) \wedge \bigwedge_{l' \in L \setminus \{l\}}(\neg \delta_s(l')) ) \]
Then we can build the transition relations $\gsRhoE$ and $\gsRhoS$ from $\Delta_A$ as follows:

\[ \gsRhoE = \bigwedge_{s_i \in S_A} \bigcirc(mux_e(s_i,\cup_{(s_i,l,s_j)}l))\]
\[ \gsRhoS = (\bigwedge_{s_i \in S_A} \bigcirc(mux_s(s_i,\cup_{(s_i,l,s_j)}l)) \wedge (\bigwedge_{(s_k,l',s_l) \in \Delta_A} (s(k) \wedge \delta_s(l') \implies \bigcirc(s(l))\]

Now we have the following, mapping:

\[\xymatrix@C+1pc{
	\langle E = \langle S, \Sigma, \Delta, s_0 \rangle, \mathcal{C} \rangle \ar@{<->}[d]^{clts}_{gs}
	& \varphi_{CLTS}\ar@{<->}[d]^{fl}_{val}
	& C\ar@{<->}[d]^{clts}_{gs}
	& \exists C: E\parallel C \models  \varphi_{CLTS}\ar@{<=>}[d]\\
	G = \langle \mathcal{X},\mathcal{Y},\theta_e,\theta_s,\rho_e,\rho_s, \emptyset \rangle
	& \varphi_G
	& D
	&\exists D: D \models \varphi_G\\
}\]

Where the strict realizability formula is:

\[\varphi_G = (\theta_e \implies \theta_s) \wedge (\theta_e \implies \square((\boxdot \rho_e) \implies \rho_s)) \wedge (\theta_e \wedge \rho_e \implies \varphi_{FDS}) \]

And we can prove:

\[E\parallel C \models  \varphi \iff gs(C) \models (\theta_e \implies \theta_s) \wedge (\theta_e \implies \square((\boxdot \rho_e) \implies \rho_s)) \wedge (\theta_e \wedge \rho_e \implies val(\varphi))
 \]
\[clts(G) \parallel clts(D) \models  fl(\varphi) \iff D \models \varphi \]