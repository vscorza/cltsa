When writing a specification or an abstraction of a digital system it is convenient to describe its behavior with game structures. This formalism captures the semantic of a two player game where the first participant, the environment, observes the state of both input and output variables at a given point of time to define a new valuation for the input, only then the second player, the system, observes both the previous and the current partial states to define the new valuation for the output. 

The set of possible actions for each player is described as relations between current and next (primed) state's variables. Satisfaction of $\gsRhoE: \gsX \times \gsY \times \gsX'$ describes the values that $\gsX'$ can take when $\gsX$ and $\gsY$ are fixed. Both the initial conditions and the transition relations can be described as boolean formulas which in turn can be represented with OBDDs. OBDDs can be composed, restricted over a subset of known values, checked for satisfiability and equality among other operations. Algorithms that work with OBDDs can and do process sets of states at each step, but finite state machines, such as CLTS, can only be processed one state at a time.

\begin{definition}
	\label{def:GS} \emph{(Game Structures)} 
	A \emph{Game Structure} (GS) $G =  \langle \gsV, \gsX, \gsY, \gsTheE, \gsTheS, \gsRhoE, \gsRhoS, \varphi \rangle$ consists of the following:
	\begin{itemize}
		\item $\gsV = \{v_1,\ldots,v_n\}$ : A finite set of typed state variables over finite domains, without loss of generality we assume that they are all Boolean. In the context of a game structure a state is defined as an assignment of $\gsV$, $s \in \Sigma_{\gsV}$.
		\item $\gsX \subseteq \gsV$ is a set of input variables.
		\item $\gsY = \gsV \setminus \gsX$ is a set of output variables.
		\item $\gsTheE$ is an assertion over $\gsX$ characterizing the initial states of the environment.
		\item $\gsTheS$ is an assertion over $\gsV$ characterizing the initial states of the system.		
		\item $\gsRhoE(\gsV,\gsX')$ is the transition relation of the environment, it identifies a valuation $s_{\gsX} \in \Sigma_{\gsX}$ as a possible input in state $s$ if $(s,s_{\gsX}) \models \gsRhoE$.
		\item $\gsRhoS(\gsV,\gsX',\gsY')$ is the transition relation of the system, it identifies a valuation $s_{\gsY} \in \Sigma_{\gsY}$ as a possible output in state $s$ reading input $s_{\gsX} $if $(s,s_{\gsX}, s_{\gsY}) \models \gsRhoS$.		
		\item $\varphi$ is the winning condition, given by an LTL formula.
	\end{itemize} 
\end{definition}

Many non trivial digital designs require the definition of state machines to some extent or another, while at the same time high level specifications can involve interactions with digital or truly concurrent components. Under these circumstances a mixed specification over both a finite state process algebra and a LTL game structure definition is desirable.  In order to reason about their composed behavior a proper common representation is needed. Our approach is to transform the game structure into its equivalent finite state automaton and then compose both using one of the parallel composition semantics.

Algorithm ~\ref{fig:gs_to_clts_algorithm} takes a game structure, represented as a set 
$\gsTheE$, $\gsTheS$, $\gsRhoE$, $\gsRhoS$, $\varphi$ of OBDDs, one for each formula, and produces the CLTS automaton $A$ that preserves its behavior. Since the state space is finite ($2^{|\gsV|}$ at most) and the number of states reached by applying $\gsRhoS(\gsRhoE(v))$ increases monotonically (when starting from $\gsTheS(\gsTheE)$), a least fixed point exists, the algorithm computes such fixed point while progressively creating the transition relation $\Delta$. \texttt{valuations}($\psi$) gives the set of valuations over $\gsV$ for a formula $\psi$ represented with an OBDD. Each valuation induces a unique state in $A$. \texttt{restrict}($\psi$, $s$) fixes a subset of variables in $\psi$ according to $s$ a valuation. If $\varphi$ is the set of propositional formulas involved in the winning condition, \texttt{evaluate\_condition}($A$, $\varphi$, $s$) evaluates the satisfaction of each such formulas according to valuation $s$ and maps the result to $s$ as a state in $A$.
\newpage
\input{gs_to_clts_code}