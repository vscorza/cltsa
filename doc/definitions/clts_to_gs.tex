
We introduce now a translation from CLTS to LTL based reactive systems specifications. We will note $\Sigma \setminus \controlSet$ as $\nonControlSet$-


In order to show the relation between a LTL based reactive system specification and a CLTS control problem we introduce a set of translations first and then present and prove a realizability preserving theorem.

The liveness part of the CLTS control problem translation is performed by the $val$ function as follows.
\begin{definition}
	\label{def:val_ltl} \emph{(LTL over set of accepting states to LTL over $\mathcal{V}$ translation)} 
	Let $\varphi$ be a LTL formula over set of accepting states $\acceptors$, and $\mathcal{V}$ the minimal set of boolean variables containing a variable $v_{\acceptingSymbol}$ for each $\acceptingSymbol \in \acceptingSymbols(\acceptors)$ , then $val(\varphi)$ is an equivalent LTL formula over boolean variables and is defined as follows:\\
	
	\begin{tabular}{ l c l }
		$val(\acceptingSymbol)$ & $\triangleq$ & $v_{\acceptingSymbol}$\\	
		$val(\neg \varphi)$ & $\triangleq$ & $\neg val(\varphi)$\\
		$val(\varphi \vee \psi$ & $\triangleq$ & $val(\varphi) \vee val(\psi)$\\
		$val(\bigcirc \varphi)$ & $\triangleq$ & $\bigcirc val(\varphi)$\\
		$val(\varphi \U \psi)$ & $\triangleq$ & $val(\varphi) \U val(\psi)$\\
	\end{tabular}	
\end{definition}

%\begin{definition}
%	\label{def:clts_to_gs_translation} \emph{(CLTS to Game Structure translation)} 
%	Let $A = \langle S_A, \Sigma_A, \Delta_A, s_{0_A} \rangle$ be a clts, and $\mathcal{C}\subseteq \Sigma_A$ its controllable alphabet, $gs(A,\mathcal{C})=B$ is a game structure such that $A \models \varphi$ $\iff$ $B \models val(\varphi)$.
%\end{definition}
%
%Let $A$ be the CLTS to be translated and $B =  \langle \gsX, \gsY, \gsTheE, \gsTheS, \gsRhoE, \gsRhoS, \varphi \rangle$ the game structure resulting after applying $gs(A)$. 
In order to build the LTL formula equivalent of a given control problem \controlProblemDef, we present the decomposition of the plant $E$ as a set of initial and transition formulae.
The alphabet of the translation will be comprised of two sets:
\[\gsX = \{x_i : a_i \in \nonControlSet \}\]
\[\gsY = \{y_i : a_i \in \controlSet \} \cup \{\varState{j} : s_j \in S_A \} \cup \{v_{\acceptingSymbol} : \acceptingSymbol \in \acceptingSymbols(\acceptors)\}\]
In the previous sets, $x_i$ is a boolean variable representing the occurrence of an environmental action, $y_i$ is a boolean variable representing the occurrence of a system action, $\varState{j}$ represents the fact that the plant is currently on state $j$ and $v_{\acceptingSymbol}$ indicates that state $j$ satisfies condition $\acceptingSymbol$, these will be called acceptance variables.
%From now on we will write $s(j)$ to represent the valuation of the system variables representing a given state $j$, i.e.: 
%\[s(j) = \bigwedge\limits^{\lfloor log_2(|S_A|)\rfloor - 1}_{i=0}  s_{bit}(i,j)\]
%\[
%s_{bit}(i,j) = \begin{cases}
%s_i & j / 2^i \\
%\neg s_i & otherwise
%\end{cases}
%\]
To represent acceptance of $\acceptingSymbol$ at state $i$ we will use $v(\acceptingSymbol,i)$:
\[
v(\acceptingSymbol,i) = \begin{cases}
v_{\acceptingSymbol} & s_i \in \acceptors(\acceptingSymbol) \\
\neg v_{\acceptingSymbol} & otherwise
\end{cases}
\]

The initial condition formula will be defined as:
\[\gsTheE = \bigwedge_{i = 1}^{|\nonControlSet|}\neg x_i\]
\[\gsTheS = (\bigwedge_{i = 1}^{|\mathcal{C}|}\neg y_i) \wedge \varState{0} \wedge (\bigwedge_{\acceptingSymbol \in \acceptingSymbols(\acceptors)}v(\acceptingSymbol,0))\]
Transition relations are constructed as a conjunction of safety formulae that are added for each state. These can be split into two types, enabling and state updating formulae. The first type restrict the set of variables that can be set to $true$ in a mutually exclusive fashion at each state, representing the label of the transition picked from a given state. The second type defines the state reached for each combination of current state and enabled variables. 
We will use the following two functions to build the conjunction of system or environment variables related to the label in any given automaton transition:
\[
var(l, \sigma_i) = \begin{cases}
\sigma_i & \sigma_i \in l \\
\neg \sigma_i & otherwise
\end{cases}
\]
\[label_e(l) = \{\bigwedge_{\sigma_i \in \nonControlSet}var(l, \sigma_i)\}\]
\[label_s(l) = \{\bigwedge_{\sigma_i \in \Sigma}var(l, \sigma_i)\}\]
And the enabling formula, which is a mutually exclusive condition over label variables for any given state $s_i$ is described as:
\[labels_e(L) = \bigvee_{l \in L}(label_e(l) \wedge \bigwedge_{l' \in L \setminus \{l\}}(\neg label_e(l')) ) \]
\[labels_s(L) = \bigvee_{l \in L}(label_s(l) \wedge \bigwedge_{l' \in L \setminus \{l\}}(\neg label_s(l')) ) \]
\[enable_e(\varState{i},L) = \varState{i} \implies labels_e(L) \]
\[enable_s(\varState{i},L) = \varState{i} \implies labels_s(L) \]
Then we can build the transition relations $\gsRhoE$ and $\gsRhoS$ from $\Delta_A$ as a conjunction of the enabling and transition formulae:


\begin{tabular}{ l c l }
	$\gsRhoE$ &$=$& $\bigwedge_{s_i \in S_A} \bigvee_{l \in (s_i,l,s_j)}\bigcirc(enable_e(\varState{i},l))$\\
	$\rho_{enabling}$ &$=$&$(\bigwedge_{s_i \in S_A} \bigvee_{l \in (s_i,l,s_j)}\bigcirc(enable_s(\varState{i},l))$\\
	$\rho_{\bigcirc S}$&$=$&$(\bigwedge_{(s_o,l',s_p) \in \Delta_A} \varState{o} \wedge \delta_s(l') \implies \bigcirc(\varState{p} \wedge\bigwedge_{s_q \neq s_p, s_q \in S}\neg \varState{q}) ) )$\\
	$\rho_{\bigcirc \acceptingSymbol}$&$=$&$(\bigwedge_{(s_o,l',s_p) \in \Delta_A} \varState{o} \wedge \delta_s(l') \implies \bigcirc(\bigwedge_{\acceptingSymbol \in \acceptingSymbols(\acceptors)}v(\acceptingSymbol,l) ) ) )$\\	
	$\gsRhoS$&$=$&$\rho_{enabling} \wedge  \rho_{\bigcirc S} \wedge  \rho_{\bigcirc \acceptingSymbol}$\\	
\end{tabular}

The first formula, $\gsRhoE$ restricts the set of environment label variables that can be enabled for any given state, $\rho_{enabling}$ does the same for system label variables, $\rho_{\bigcirc S}$ defines the next state according to the current one and the selected label, and $\rho_{\bigcirc \acceptingSymbol}$ updates the accepting conditions according to the next state, $\gsRhoS$ is the system transition formula, defined as a conjunction of the previous ones.
%
%Now we have the following mapping:
%
%\[\xymatrix@C+1pc{
%	\langle E = \langle S, \Sigma, \Delta, s_0 \rangle, \mathcal{C} \rangle \ar@{<->}[d]^{clts}_{gs}
%	& \varphi_{CLTS}\ar@{<->}[d]^{fl}_{val}
%	& C\ar@{<->}[d]^{clts}_{gs}
%	& \exists C: E\parallel C \models  \varphi_{CLTS}\ar@{<=>}[d]\\
%	G = \langle \mathcal{X},\mathcal{Y},\theta_e,\theta_s,\rho_e,\rho_s, \emptyset \rangle
%	& \varphi_G
%	& D
%	&\exists D: D \models \varphi_G\\
%}\]

%The following will be used to later define an FDS:
%\[\theta = \theta_e \wedge \theta_s, \rho = \rho_e \wedge \rho_s \]

The LTL equivalent formula to control problem \controlProblemDef can be defined as:

\[ \varphiLtl \]

Now we can show that realizability is preserved between CLTS control problem $\controlProblem$ and embedding $ltl(\controlProblem)$.

\begin{theorem}(\emph{$ltl$ preserves realizability})\label{theorem:gs_preserves_realizability}\\
	Let \controlProblemDef be a CLTS control problem with \cltsDef{E} and $\Sigma = \mathcal{C}\uplus \mathcal{U}$ then if $ltl(\controlProblem) = \langle \varphi_{ltl}, \gsX, \gsY\rangle$:
	\small
	\[(\exists D= \langle \mathcal{V}_d, \theta_d, \rho_d, \mathcal{J}_d, \mathcal{C}_d\rangle    \gsX, \gsY \in \mathcal{V}_d, \mathcal{D} \text{ is fairness-free, complete w.r.t. } \gsX \text{: } D \models \varphi_{ltl}\]
	% \wedge \exists \sigma \in D: \sigma \models \theta_e \wedge \square \rho_e) \]
	 \[ \iff (\exists C \text{ legal w.r.t. } E,\mathcal{C} \text{: } C \parallel E \text{ is deadlock-free and } C \parallel E \models \varphi)  \]
	\normalsize
\end{theorem}

%, with an additional condition for LTL based reactive systems ($\sigma \models \theta_d \wedge \square \rho_d$) ruling out the cases where $val(\varphi)$ is never satisfied, since $\varphi_{LTL}$ could be realized by achieving $\neg\theta \vee \diamond \neg \rho$. In such a case no controller can be built for $\mathcal{I}$ s.t. $\varphi$ is satisfied since it will violate the safety restrictions related to the behavior of the plant $E_G$.

The proof is split in two parts, first we prove that if a controller exists for $\controlProblem$, a DFS exists for $\varphi_{LTL}$. Then we prove the opposite direction. For the ($\controlProblem \rightarrow \varphi_{LTL}$) step we construct a FDS from controller $C$ through a specific embedding $fds(C)$ and then prove that each property holds. For the ($\varphi_{LTL} \rightarrow \mathcal{I}$) we construct a controller from FDS $D$ through a specific embedding $ctrl(D)$ and then prove each property for this controller. The outline of the proof is as follows:

\begin{description}
	\item[($\controlProblem \rightarrow \varphi_{LTL}$)] Given \controlProblemDef and $ltl(\controlProblem) = \langle \varphi_{ltl}, \gsX, \gsY\rangle$
		\begin{itemize}
			\item $fds(C)$ is a fairness-free FDS			
			\item $fds(C)$ is complete w.r.t. $\mathcal{X}$
			\item $fds(C) \models \varphi_{LTL}$
		%	\item $\exists \sigma \in D: \sigma \models \theta_e \wedge \square \rho_e$			
		\end{itemize}
	\item[($\varphi_{LTL} \rightarrow \mathcal{I}$)] Given $\varphi_{ltl}, \gsX, \gsY$ and FDS $D$
		\begin{itemize}
			\item $ctrl(D)$ is a deadlock-free CLTS			
			\item $ctrl(D)$ is legal w.r.t. $E$ and $\mathcal{C}$
			\item $ctrl(D) \models \varphi$
		\end{itemize}	
\end{description}

First,  for the $\mathcal{I} \rightarrow \varphi_{LTL}$ step, $fds$ constructs FDS $\langle \mathcal V_d, \theta_d, \rho_d, \mathcal{J}_d, \mathcal{C}_d \rangle$ from a control problem $\controlProblem$ and controller $C$ using the formulas defined for $\varphi_{LTL}$, but instead of using $E$ when building $\theta_e,\theta_s,\rho_e,\rho_s$ we will use $C$ and the elements of the FDS are as follows:

	\begin{tabular}{ l c l }
	$V_d$ & $=$ & $\mathcal{X} \cup \mathcal{Y}$\\	
	$\theta_d$ & $=$ & $(\theta_e \implies \theta_s)$\\
	$\rho_d$ & $=$ & $(\rho_e \implies \rho_s)$\\	
	$\mathcal{J}_d$ & $=$ & $\emptyset$\\
	$\mathcal{C}_d$ & $=$ & $\emptyset$\\
\end{tabular}

It is easy to see that $fds(C)$ is fairness-free by construction. This also holds for the complete w.r.t. $\mathcal{X}$ property, since no restriction is placed upon environment variables. Now, to prove that $fds(C)$ satisfies $\varphi_{LTL}$ we state the following:

\[\forall \sigma \in D: \sigma \models \varphi_{LTL} \]

We split the proof in two again, first assuming $\sigma \not\models \theta_e \wedge \square \rho_e$, i.e.: $\sigma \models \neg\theta_e \vee \Diamond \neg\rho_e$, in this case $\varphi_{LTL}$ is trivially satisfied. Now if $\sigma \models \theta_e \wedge \square \rho_e$ holds it should also satisfy $\theta_s$, $\square\rho_s$ and $val(\varphi)$. Since $\sigma$ is a play in $fds(C)$ then $\theta_d=(\theta_e \implies \theta_s)$ and $\rho_d=(\rho_e \implies \rho_s)$ hold, and since it also satisfies $\theta_e \wedge \square \rho_e$ we observe the following:
\[((\theta_e \implies \theta_s) \wedge \theta_e))\implies \theta_s\]
\[((\rho_e \implies \rho_s) \wedge \rho_e))\implies \rho_s\]
To show that $\sigma$ also satisfies $val(\varphi)$ we prove that there is an execution $\execution$ in $C$ that follows $\sigma$.
For a play $\sigma \in 2^{|\mathcal{V}|^{\omega}}$ we define $exec(\sigma) \in S^{\omega}$ as follows, suppose that $\sigma = \sigma_1 \sigma_2 \ldots \sigma_i \ldots$ and
$exec(\sigma)= \execution_1 \execution_2 \ldots \execution_i \ldots$, then $\execution_i = s_j \iff \sigma_i \models \varState{j}$. For each pair ($\sigma_i$,$\sigma_{i+1}$), since $\sigma \models \rho_e \wedge \rho_s$, by restriction $\rho_s$
We observe that $\sigma_i \models s_j$ implies that there exists a transition $(j, l, k)$ s.t.$\sigma_{i+1} \models s_k$ and $\sigma_{i+i} \models \delta_s(l) \wedge \bigwedge_{l' \in L \setminus \{l\}}(\neg \delta_s(l'))$, and in particular $\sigma_0 \models s_0$, from which follows that $\pi \in C$.
Since for each play $\sigma$ that satisfies $\theta_e \wedge \square \rho_e$ we have a trace $\pi$ in controller $C$, and since $C \models \varphi$ we can show that $\sigma \models val(\varphi)$.


This is proved over the syntactic construction of $\varphi$, we will only show the base case of atomic satisfaction, i.e.
$\pi \models val(fl_i) \implies \sigma \models v_{fl_i}$. Again, looking at $\gsRhoS$, $\bigwedge_{f = 1}^{|\mathcal{F}|}f_{val}(f,l)$ after the next state operator updates valuation of fluent variables according to $val(fl_i)$ at state $i+1$, proving that $\pi \models val(fl_i) \implies \sigma \models v_{fl_i}$.


