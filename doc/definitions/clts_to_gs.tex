
We introduce now a translation from CLTS to LTL based reactive systems specifications. We will note $\Sigma \setminus \controlSet$ as $\nonControlSet$. In order to show the relation between a LTL based reactive system specification and a CLTS control problem we first introduce a set of embeddings, then present and prove a realizability preserving theorem between the original control problem and its embedding into a reactive system specification.


In order to embed the CLTS control problem $\controlProblem$ into a LTL reactive system specification, the LTL formula over atomic propositions is translated simply by replacing each occurrence of an atomic proposition $\proposition \in \propositions$ with the boolean variable variable $v_{\proposition}$.
%\begin{definition}
%	\label{def:val_ltl} \emph{(LTL over $\propositions$ to LTL over $\mathcal{V}$ translation)} 
%	Let $\varphi$ be a LTL formula over set of atomic propositions $\propositions$, and $\mathcal{V}$ the minimal set of boolean variables containing a variable $v_{\proposition}$ for each $\proposition \in \propositions$, then $val(\varphi)$ is an equivalent LTL formula over boolean variables and is defined as follows:\\
%	
%	\begin{tabular}{ l c l }
%		$val(\proposition)$ & $\triangleq$ & $v_{\proposition}$\\	
%		$val(\neg \varphi)$ & $\triangleq$ & $\neg val(\varphi)$\\
%		$val(\varphi \vee \psi$ & $\triangleq$ & $val(\varphi) \vee val(\psi)$\\
%		$val(\bigcirc \varphi)$ & $\triangleq$ & $\bigcirc val(\varphi)$\\
%		$val(\varphi \U \psi)$ & $\triangleq$ & $val(\varphi) \U val(\psi)$\\
%	\end{tabular}	
%\end{definition}

%\begin{definition}
%	\label{def:clts_to_gs_translation} \emph{(CLTS to Game Structure translation)} 
%	Let $A = \langle S_A, \Sigma_A, \Delta_A, s_{0_A} \rangle$ be a clts, and $\mathcal{C}\subseteq \Sigma_A$ its controllable alphabet, $gs(A,\mathcal{C})=B$ is a game structure such that $A \models \varphi$ $\iff$ $B \models val(\varphi)$.
%\end{definition}
%
%Let $A$ be the CLTS to be translated and $B =  \langle \gsX, \gsY, \gsTheE, \gsTheS, \gsRhoE, \gsRhoS, \varphi \rangle$ the game structure resulting after applying $gs(A)$. 
Next we present the decomposition of the plant $E$ as a set of initial and transition formulae.
The alphabet of the translation will be comprised of two sets:
\[\gsX = \{x_i : c_i \in \nonControlSet \}\]
\[\gsY = \{y_i : u_i \in \controlSet \} \cup \{\varState{j} : s_j \in S_A \} \cup \{v_{\proposition} : \proposition \in \propositions\}\]
In the previous sets, $x_i$ is a boolean variable representing the occurrence of an environmental action, $y_i$ is a boolean variable representing the occurrence of a system action, $\varState{j}$ represents the fact that the plant is currently on state $j$ and $v_{\proposition}$ indicates that state $j$ satisfies proposition $\proposition$, the latest will be called natural variables in the context of this embedding.
%From now on we will write $s(j)$ to represent the valuation of the system variables representing a given state $j$, i.e.: 
%\[s(j) = \bigwedge\limits^{\lfloor log_2(|S_A|)\rfloor - 1}_{i=0}  s_{bit}(i,j)\]
%\[
%s_{bit}(i,j) = \begin{cases}
%s_i & j / 2^i \\
%\neg s_i & otherwise
%\end{cases}
%\]
To embed satisfaction of $\proposition$ at state $i$ we use $v(\proposition,i)$:
\[
v(\proposition,i) = \begin{cases}
v_{\proposition} & \proposition \in \valuations(s_i) \\
\neg v_{\proposition} & otherwise
\end{cases}
\]
We will use the following two functions to build the conjunction of system or environment variables related to the label in any given automaton transition (note that here $l$ is a label composed of several actions or events):
\[
var(l, l_i) = \begin{cases}
\varLabel{i} & l_i \in l \\
\neg \varLabel{i} & otherwise
\end{cases}
\]
\[label_e(l) = \{\bigwedge_{l_i \in \nonControlSet}var(l, l_i)\]
\[label_s(l) = \{\bigwedge_{l_i \in \Sigma}var(l, l_i)\}\]
And the enabling formula, which is a mutually exclusive condition over label variables for any given state $s_i$ is described as (note again that $L$ is a set of labels enabled for a particular state, each one consisting of several actions or events):
\[labels_e(L) = \bigvee_{l \in L}(label_e(l) \wedge \bigwedge_{l' \in L \setminus \{l\}}(\neg label_e(l')) ) \]
\[labels_s(L) = \bigvee_{l \in L}(label_s(l) \wedge \bigwedge_{l' \in L \setminus \{l\}}(\neg label_s(l')) ) \]
The initial condition formula will be defined as:
\[\gsTheE = \bigvee_{(s_0,l,s_j) \in \Delta_A}labels_e(l)\]
\[\gsTheS = (\varState{0} \wedge\bigwedge_{s_j \neq s_0, s_q \in S}\neg \varState{j})  \wedge \bigvee_{(s_0,l,s_j) \in \Delta_A}labels_s(l) \wedge \bigwedge_{\proposition \in \propositions}v(\proposition,0)\]
\[\theta = \gsTheE \wedge \gsTheS\]
Transition relations are constructed as a conjunction of safety formulae that are defined for each state. These can be split into two types, enabling and updating formulae. The first type restrict the set of variables that can be set to $true$ in a mutually exclusive fashion at each state, representing the label of the transition picked from any given state. The second type defines the state reached for each combination of current state and enabled natural variables. 

Then we can build the transition relations $\gsRhoE$ and $\gsRhoS$ from $\Delta_A$ as a conjunction of the enabling and transition formulae:

\vspace{1em}
\begin{tabular}{ l c l }
	$\rho_{env.enabling}$ &$=$& $\bigwedge_{s_i \in S_A} \varState{i} \implies \bigvee_{(s_i,l,s_j) \in \Delta_A}labels_e(l)$\\
	$\rho_{sys.enabling}$ &$=$& $\bigwedge_{s_i \in S_A} \varState{i} \implies \bigvee_{(s_i,l,s_j) \in \Delta_A}labels_s(l)$\\
	&&\\
	$\rho_{update.states}$&$=$&$\bigwedge_{(s_i,l,s_j) \in \Delta_A} (\varState{i} \wedge label_s(l) \implies \bigcirc(\varState{j} \wedge\bigwedge_{s_q \neq s_j, s_q \in S}\neg \varState{q}) ) $\\
	$\rho_{update.propositions}$&$=$&$\bigwedge_{(s_i,l,s_j) \in \Delta_A} (\varState{i} \wedge label_s(l) \implies \bigcirc(\bigwedge_{\proposition \in \propositions}v(\proposition,j) ) )$\\
	&&\\
	$\gsRhoS$&$=$&$\rho_{sys.enabling} \wedge  \rho_{update.states} \wedge  \rho_{update.propositions}$\\	
\end{tabular}
\vspace{1em}

The first formula, $\rho_{env.enabling}$ restricts the set of environment label variables that can be enabled for any given state, $\rho_{sys.enabling}$ does the same for system label variables, $\rho_{update.states}$ defines the next state according to the current one and the selected label, and $\rho_{update.propositions}$ updates the natural variables according to the next state, $\gsRhoS$ is the system transition formula, defined as a conjunction of the previous ones.
%
%Now we have the following mapping:
%
%\[\xymatrix@C+1pc{
%	\langle E = \langle S, \Sigma, \Delta, s_0 \rangle, \mathcal{C} \rangle \ar@{<->}[d]^{clts}_{gs}
%	& \varphi_{CLTS}\ar@{<->}[d]^{fl}_{val}
%	& C\ar@{<->}[d]^{clts}_{gs}
%	& \exists C: E\parallel C \models  \varphi_{CLTS}\ar@{<=>}[d]\\
%	G = \langle \mathcal{X},\mathcal{Y},\theta_e,\theta_s,\rho_e,\rho_s, \emptyset \rangle
%	& \varphi_G
%	& D
%	&\exists D: D \models \varphi_G\\
%}\]

%The following will be used to later define an FDS:
%\[\theta = \theta_e \wedge \theta_s, \rho = \rho_e \wedge \rho_s \]

The LTL equivalent formula to control problem \controlProblemDef can be defined as:

\[ \varphiLtl \]

Now we can show that realizability is preserved between CLTS control problem $\controlProblem$ and embedding $ltl(\controlProblem)$.

\begin{theorem}(\emph{$ltl$ preserves realizability})\label{theorem:gs_preserves_realizability}\\
	Let \controlProblemDef be a CLTS control problem with \cltsDef{E} and $\Sigma = \mathcal{C}\uplus \mathcal{U}$ then if $ltl(\controlProblem) = \langle \varphi_{ltl}, \gsX, \gsY\rangle$:
	\small
	\[(\exists D:FDS|D= \langle \mathcal{V}_d, \theta_d, \rho_d, \mathcal{J}_d, \mathcal{C}_d\rangle, \text{s.t. }    \gsX, \gsY \in \mathcal{V}_d, D \text{ is fairness-free, complete w.r.t. } \gsX \text{: } D \models \varphi_{ltl}\]
	% \wedge \exists \sigma \in D: \sigma \models \theta_e \wedge \square \rho_e) \]
	 \[ \iff (\exists C:CLTS| C \text{ legal w.r.t. } E,\mathcal{C} \text{: } C \parallel E \text{ is deadlock-free and } C \parallel E \models \varphi)  \]
	\normalsize
\end{theorem}

%, with an additional condition for LTL based reactive systems ($\sigma \models \theta_d \wedge \square \rho_d$) ruling out the cases where $val(\varphi)$ is never satisfied, since $\varphi_{LTL}$ could be realized by achieving $\neg\theta \vee \diamond \neg \rho$. In such a case no controller can be built for $\mathcal{I}$ s.t. $\varphi$ is satisfied since it will violate the safety restrictions related to the behavior of the plant $E_G$.

The proof is split in two parts, first we prove that if a controller exists for $\controlProblem$, a DFS exists for $\varphi_{LTL}$. Then we prove the opposite direction. For the ($\controlProblem \rightarrow \varphi_{LTL}$) step we construct a FDS from controller $C$ through a specific embedding $fds(C)$ and then prove that each property holds. For the ($\varphi_{LTL} \rightarrow \mathcal{I}$) we construct a controller from FDS $D$ through a specific embedding $ctrl(D)$ and then prove each property for this controller. The outline of the proof is as follows:

\begin{description}
	\item[($\controlProblem \rightarrow \varphi_{LTL}$)] Given \controlProblemDef and $ltl(\controlProblem) = \langle \varphi_{ltl}, \gsX, \gsY\rangle$
		\begin{itemize}
			\item $fds(C)$ is a fairness-free FDS			
			\item $fds(C)$ is complete w.r.t. $\mathcal{X}$
			\item $fds(C) \models \varphi_{LTL}$
		%	\item $\exists \sigma \in D: \sigma \models \theta_e \wedge \square \rho_e$			
		\end{itemize}
	\item[($\varphi_{LTL} \rightarrow \mathcal{I}$)] Given $\varphi_{ltl}, \gsX, \gsY$ and FDS $D$
		\begin{itemize}
			\item $ctrl(D)$ is a deadlock-free CLTS			
			\item $ctrl(D)$ is legal w.r.t. $E$ and $\mathcal{C}$
			\item $ctrl(D) \models \varphi$
		\end{itemize}	
\end{description}

First,  for the $\mathcal{I} \rightarrow \varphi_{LTL}$ step, $fds$ constructs FDS $D=\langle \mathcal V_d, \theta_d, \rho_d, \mathcal{J}_d, \mathcal{C}_d \rangle$ from a control problem $\controlProblem$ and controller $C$ using the formulas defined for $\varphi_{LTL}$, i.e. $\gsTheE, \gsTheS, \gsRhoE, \gsRhoS$, with the consideration that instead of using $E$ when building them we will use $C$ and the elements of the FDS are going to be defined as follows:

	\begin{tabular}{ l c l }
	$V_d$ & $=$ & $\mathcal{X} \cup \mathcal{Y}$\\	
	$\theta_d$ & $=$ & $(\theta_e \implies \theta_s)$\\
	$\rho_d$ & $=$ & $(\rho_e \implies \rho_s)$\\	
	$\mathcal{J}_d$ & $=$ & $\emptyset$\\
	$\mathcal{C}_d$ & $=$ & $\emptyset$\\
\end{tabular}

We can easily see that $fds(C)$ is fairness-free and complete w.r.t. $\mathcal{X}$ by construction, the first property is obvious, the second holds since no restriction is placed upon environment variables. Now, to prove that $fds(C)$ satisfies $\varphi_{LTL}$ we observe all paths in $D$ do, i.e.:

\[\forall \sigma \in D: \sigma \models \varphi_{LTL} \]

We split the proof in two again, first assuming $\sigma \not\models \theta_e \wedge \square \rho_e$, i.e.: $\sigma \models \neg\theta_e \vee \Diamond \neg\rho_e$, in this case $\varphi_{LTL}$ is trivially satisfied since all the precedents in the general conjunction terms are falsified. Now if $\sigma \models \theta_e \wedge \square \rho_e$ holds it should also satisfy $\theta_s$, $\square\rho_s$ and $val(\varphi)$. Since $\sigma$ is a play in $fds(C)$ then $\theta_d=(\theta_e \implies \theta_s)$ and $\rho_d=(\rho_e \implies \rho_s)$ hold, and since it also satisfies $\theta_e \wedge \square \rho_e$ we observe the following:
\[((\theta_e \implies \theta_s) \wedge \theta_e))\implies \theta_s\]
\[((\rho_e \implies \rho_s) \wedge \rho_e))\implies \rho_s\]
To show that $\sigma$ also satisfies $val(\varphi)$ we prove that for every play $\sigma$ in $fds(C)$ there is an execution $\execution$ in $C$ that conform to it.
For a play $\sigma \in 2^{|\mathcal{V}|^{\omega}}$ we define $exec(\sigma) \in S^{\omega}$ as follows, suppose that $\sigma = \sigma_1 \sigma_2 \ldots \sigma_i \ldots$ and
$exec(\sigma)= \execution_1 \execution_2 \ldots \execution_i \ldots$, then $\execution_i = s_j \iff \sigma_i \models \varState{j}$, to prove that such execution is possible in $C$ we observe that for each pair ($\sigma_i$,$\sigma_{i+1}$), since $\sigma \models \rho_e \wedge \rho_s$, and $\rho_s$ forces
plays to assign states according to transitions in $\Delta_C$, if $\sigma_i \models s_j$ then there exists a transition $(j, l, k)$ s.t.$\sigma_{i+1} \models s_k$ and $\sigma_{i+i} \models \delta_s(l) \wedge \bigwedge_{l' \in L \setminus \{l\}}(\neg \delta_s(l'))$. Then, for the base case we know that $\sigma_0 \models s_0$ by construction, therefore we proved that $exec(\sigma) \in C$.
Since for each play $\sigma$ that satisfies $\theta_e \wedge \square \rho_e$ we have a trace $\pi$ in controller $C$, and since $C \models \varphi$ we can show that $\sigma \models val(\varphi)$.


This is proved over the algebraic construction of $\varphi$, and we will only show the base case of atomic satisfaction, where
$exec(\sigma) \models \proposition$ implies $\sigma \models v_{\proposition}$. Again, for any given state $s_i \in exec(\sigma)$, satisfaction of the natural variable $v_{\proposition}$ will be preserved by  $\rho_{update.propositions}$ through $\bigwedge_{\proposition \in \propositions}v(\proposition,j)$.\\
\\

Now,  for the $\varphi_{LTL} \rightarrow \mathcal{I}$ direction, we propose an embedding $clts$ from an FDS into a CLTS that will preserve only the behavior that satisfies $\theta_e \wedge \square \rho_e$, since otherwise we will be keeping traces in $clts(D)$ that are not feasible in $clts(D)\parallel E$. We can show that even after removing the set of plays that satisfy $\neg \theta_e \vee \Diamond \rho_e$, a non empty controller exists, since this would contradict the existance of a complete w.r.t. $\gsX$ FDS $D$ that satifsfies $\varphi_{LTL}$, because the environment would be able to win by satisfying $\theta_e \wedge \square \rho_e$ while the system can not achieve $val(\varphi)$. After observing this and considering that  $D= \langle \mathcal{V}_d, \theta_d, \rho_d, \mathcal{J}_d, \mathcal{C}_d\rangle$ is a solution to $\varphi_{LTL}$, which in turn was built from \controlProblemDef,  we can present the embedding $clts$ from FDS into CLTS as \cltsEmbeddingDef{D} as follows :

\vspace{1em}
\begin{tabular}{ l c l }
	$S$ &$=$& $S_E$\\
	$\Sigma$ &$=$&$\Sigma_E$\\	
	$s_0$&$=$&$s_0^{E}$\\
	$\valuations$&$=$&$\valuations_E$\\
	&&\\
	$\Delta$&$=$&$\{(s_i,l,s_j)| \rho_d \models \varState{i} \wedge \bigcirc \varState{j} \wedge labels_e(l) \wedge labels_s(l) \}$\\
\end{tabular}
\vspace{1em}