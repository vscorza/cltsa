
We introduce now a translation from CLTS to LTL based reactive systems specifications. We will note $\Sigma \setminus \controlSet$ as $\nonControlSet$. In order to show the relation between a LTL based reactive system specification and a CLTS control problem we first introduce a set of embeddings, then present and prove a realizability preserving theorem between the original control problem and its embedding into a reactive system specification.


In order to embed the CLTS control problem $\controlProblem$ into a LTL reactive system specification, the LTL formula over atomic propositions is translated as follows.
\begin{definition}
	\label{def:val_ltl} \emph{(LTL over $\propositions$ to LTL over $\mathcal{V}$ translation)} 
	Let $\varphi$ be a LTL formula over set of atomic propositions $\propositions$, and $\mathcal{V}$ the minimal set of boolean variables containing a variable $v_{\proposition}$ for each $\proposition \in \propositions$, then $val(\varphi)$ is an equivalent LTL formula over boolean variables and is defined as follows:\\
	
	\begin{tabular}{ l c l }
		$val(\proposition)$ & $\triangleq$ & $v_{\proposition}$\\	
		$val(\neg \varphi)$ & $\triangleq$ & $\neg val(\varphi)$\\
		$val(\varphi \vee \psi$ & $\triangleq$ & $val(\varphi) \vee val(\psi)$\\
		$val(\bigcirc \varphi)$ & $\triangleq$ & $\bigcirc val(\varphi)$\\
		$val(\varphi \U \psi)$ & $\triangleq$ & $val(\varphi) \U val(\psi)$\\
	\end{tabular}	
\end{definition}

%\begin{definition}
%	\label{def:clts_to_gs_translation} \emph{(CLTS to Game Structure translation)} 
%	Let $A = \langle S_A, \Sigma_A, \Delta_A, s_{0_A} \rangle$ be a clts, and $\mathcal{C}\subseteq \Sigma_A$ its controllable alphabet, $gs(A,\mathcal{C})=B$ is a game structure such that $A \models \varphi$ $\iff$ $B \models val(\varphi)$.
%\end{definition}
%
%Let $A$ be the CLTS to be translated and $B =  \langle \gsX, \gsY, \gsTheE, \gsTheS, \gsRhoE, \gsRhoS, \varphi \rangle$ the game structure resulting after applying $gs(A)$. 
Next we present the decomposition of the plant $E$ as a set of initial and transition formulae.
The alphabet of the translation will be comprised of two sets:
\[\gsX = \{x_i : c_i \in \nonControlSet \}\]
\[\gsY = \{y_i : u_i \in \controlSet \} \cup \{\varState{j} : s_j \in S_A \} \cup \{v_{\proposition} : \proposition \in \propositions\}\]
In the previous sets, $x_i$ is a boolean variable representing the occurrence of an environmental action, $y_i$ is a boolean variable representing the occurrence of a system action, $\varState{j}$ represents the fact that the plant is currently on state $j$ and $v_{\proposition}$ indicates that state $j$ satisfies proposition $\proposition$, the latest will be called natural variables in the context of this embedding.
%From now on we will write $s(j)$ to represent the valuation of the system variables representing a given state $j$, i.e.: 
%\[s(j) = \bigwedge\limits^{\lfloor log_2(|S_A|)\rfloor - 1}_{i=0}  s_{bit}(i,j)\]
%\[
%s_{bit}(i,j) = \begin{cases}
%s_i & j / 2^i \\
%\neg s_i & otherwise
%\end{cases}
%\]
To embed satisfaction of $\proposition$ at state $i$ we use $v(\proposition,i)$:
\[
v(\proposition,i) = \begin{cases}
v_{\proposition} & \proposition \in \valuations(s_i) \\
\neg v_{\proposition} & otherwise
\end{cases}
\]

The initial condition formula will be defined as:
\[\gsTheE = \bigwedge_{i = 1}^{|\nonControlSet|}\neg x_i\]
\[\gsTheS = (\bigwedge_{i = 1}^{|\mathcal{C}|}\neg y_i) \wedge \varState{0} \wedge (\bigwedge_{\proposition \in \propositions}v(\proposition,0))\]
\[\theta = \gsTheE \wedge \gsTheS\]
Transition relations are constructed as a conjunction of safety formulae that are defined for each state. These can be split into two types, enabling and updating formulae. The first type restrict the set of variables that can be set to $true$ in a mutually exclusive fashion at each state, representing the label of the transition picked from any given state. The second type defines the state reached for each combination of current state and enabled natural variables. 
We will use the following two functions to build the conjunction of system or environment variables related to the label in any given automaton transition (note that here $l$ is a label composed of several actions or events):
\[
var(l, \sigma_i) = \begin{cases}
\sigma_i & \sigma_i \in l \\
\neg \sigma_i & otherwise
\end{cases}
\]
\[label_e(l) = \{\bigwedge_{\sigma_i \in \nonControlSet}var(l, \sigma_i)\]
\[label_s(l) = \{\bigwedge_{\sigma_i \in \Sigma}var(l, \sigma_i)\}\]
And the enabling formula, which is a mutually exclusive condition over label variables for any given state $s_i$ is described as (note again that $L$ is a set of labels enabled for a particular state, each one consisting of several actions or events):
\[labels_e(L) = \bigvee_{l \in L}(label_e(l) \wedge \bigwedge_{l' \in L \setminus \{l\}}(\neg label_e(l')) ) \]
\[labels_s(L) = \bigvee_{l \in L}(label_s(l) \wedge \bigwedge_{l' \in L \setminus \{l\}}(\neg label_s(l')) ) \]
Then we can build the transition relations $\gsRhoE$ and $\gsRhoS$ from $\Delta_A$ as a conjunction of the enabling and transition formulae:

\vspace{1em}
\begin{tabular}{ l c l }
	$\rho_{env.enabling}$ &$=$& $\bigwedge_{s_i \in S_A} \bigcirc(\varState{i} \implies \bigvee_{(s_i,l,s_j) \in \Delta_A}labels_e(l))$\\
	$\rho_{sys.enabling}$ &$=$& $\bigwedge_{s_i \in S_A} \bigcirc(\varState{i} \implies \bigvee_{(s_i,l,s_j) \in \Delta_A}labels_s(l))$\\
	&&\\
	$\rho_{update.states}$&$=$&$\bigwedge_{(s_i,l,s_j) \in \Delta_A} (\varState{i} \wedge label_s(l) \implies \bigcirc(\varState{p} \wedge\bigwedge_{s_q \neq s_j, s_q \in S}\neg \varState{q}) ) $\\
	$\rho_{update.propositions}$&$=$&$\bigwedge_{(s_i,l,s_j) \in \Delta_A} (\varState{i} \wedge label_s(l) \implies \bigcirc(\bigwedge_{\proposition \in \propositions}v(\proposition,j) ) )$\\
	&&\\
	$\gsRhoS$&$=$&$\rho_{sys.enabling} \wedge  \rho_{update.states} \wedge  \rho_{update.propositions}$\\	
\end{tabular}
\vspace{1em}

The first formula, $\rho_{env.enabling}$ restricts the set of environment label variables that can be enabled for any given state, $\rho_{sys.enabling}$ does the same for system label variables, $\rho_{update.states}$ defines the next state according to the current one and the selected label, and $\rho_{update.propositions}$ updates the natural variables according to the next state, $\gsRhoS$ is the system transition formula, defined as a conjunction of the previous ones.
%
%Now we have the following mapping:
%
%\[\xymatrix@C+1pc{
%	\langle E = \langle S, \Sigma, \Delta, s_0 \rangle, \mathcal{C} \rangle \ar@{<->}[d]^{clts}_{gs}
%	& \varphi_{CLTS}\ar@{<->}[d]^{fl}_{val}
%	& C\ar@{<->}[d]^{clts}_{gs}
%	& \exists C: E\parallel C \models  \varphi_{CLTS}\ar@{<=>}[d]\\
%	G = \langle \mathcal{X},\mathcal{Y},\theta_e,\theta_s,\rho_e,\rho_s, \emptyset \rangle
%	& \varphi_G
%	& D
%	&\exists D: D \models \varphi_G\\
%}\]

%The following will be used to later define an FDS:
%\[\theta = \theta_e \wedge \theta_s, \rho = \rho_e \wedge \rho_s \]

The LTL equivalent formula to control problem \controlProblemDef can be defined as:

\[ \varphiLtl \]

Now we can show that realizability is preserved between CLTS control problem $\controlProblem$ and embedding $ltl(\controlProblem)$.

\begin{theorem}(\emph{$ltl$ preserves realizability})\label{theorem:gs_preserves_realizability}\\
	Let \controlProblemDef be a CLTS control problem with \cltsDef{E} and $\Sigma = \mathcal{C}\uplus \mathcal{U}$ then if $ltl(\controlProblem) = \langle \varphi_{ltl}, \gsX, \gsY\rangle$:
	\small
	\[(\exists D= \langle \mathcal{V}_d, \theta_d, \rho_d, \mathcal{J}_d, \mathcal{C}_d\rangle    \gsX, \gsY \in \mathcal{V}_d, \mathcal{D} \text{ is fairness-free, complete w.r.t. } \gsX \text{: } D \models \varphi_{ltl}\]
	% \wedge \exists \sigma \in D: \sigma \models \theta_e \wedge \square \rho_e) \]
	 \[ \iff (\exists C \text{ legal w.r.t. } E,\mathcal{C} \text{: } C \parallel E \text{ is deadlock-free and } C \parallel E \models \varphi)  \]
	\normalsize
\end{theorem}

\newpage

%, with an additional condition for LTL based reactive systems ($\sigma \models \theta_d \wedge \square \rho_d$) ruling out the cases where $val(\varphi)$ is never satisfied, since $\varphi_{LTL}$ could be realized by achieving $\neg\theta \vee \diamond \neg \rho$. In such a case no controller can be built for $\mathcal{I}$ s.t. $\varphi$ is satisfied since it will violate the safety restrictions related to the behavior of the plant $E_G$.

The proof is split in two parts, first we prove that if a controller exists for $\controlProblem$, a DFS exists for $\varphi_{LTL}$. Then we prove the opposite direction. For the ($\controlProblem \rightarrow \varphi_{LTL}$) step we construct a FDS from controller $C$ through a specific embedding $fds(C)$ and then prove that each property holds. For the ($\varphi_{LTL} \rightarrow \mathcal{I}$) we construct a controller from FDS $D$ through a specific embedding $ctrl(D)$ and then prove each property for this controller. The outline of the proof is as follows:

\begin{description}
	\item[($\controlProblem \rightarrow \varphi_{LTL}$)] Given \controlProblemDef and $ltl(\controlProblem) = \langle \varphi_{ltl}, \gsX, \gsY\rangle$
		\begin{itemize}
			\item $fds(C)$ is a fairness-free FDS			
			\item $fds(C)$ is complete w.r.t. $\mathcal{X}$
			\item $fds(C) \models \varphi_{LTL}$
		%	\item $\exists \sigma \in D: \sigma \models \theta_e \wedge \square \rho_e$			
		\end{itemize}
	\item[($\varphi_{LTL} \rightarrow \mathcal{I}$)] Given $\varphi_{ltl}, \gsX, \gsY$ and FDS $D$
		\begin{itemize}
			\item $ctrl(D)$ is a deadlock-free CLTS			
			\item $ctrl(D)$ is legal w.r.t. $E$ and $\mathcal{C}$
			\item $ctrl(D) \models \varphi$
		\end{itemize}	
\end{description}

First,  for the $\mathcal{I} \rightarrow \varphi_{LTL}$ step, $fds$ constructs FDS $\langle \mathcal V_d, \theta_d, \rho_d, \mathcal{J}_d, \mathcal{C}_d \rangle$ from a control problem $\controlProblem$ and controller $C$ using the formulas defined for $\varphi_{LTL}$, but instead of using $E$ when building $\theta_e,\theta_s,\rho_e,\rho_s$ we will use $C$ and the elements of the FDS are as follows:

	\begin{tabular}{ l c l }
	$V_d$ & $=$ & $\mathcal{X} \cup \mathcal{Y}$\\	
	$\theta_d$ & $=$ & $(\theta_e \implies \theta_s)$\\
	$\rho_d$ & $=$ & $(\rho_e \implies \rho_s)$\\	
	$\mathcal{J}_d$ & $=$ & $\emptyset$\\
	$\mathcal{C}_d$ & $=$ & $\emptyset$\\
\end{tabular}

It is easy to see that $fds(C)$ is fairness-free by construction. This also holds for the complete w.r.t. $\mathcal{X}$ property, since no restriction is placed upon environment variables. Now, to prove that $fds(C)$ satisfies $\varphi_{LTL}$ we state the following:

\[\forall \sigma \in D: \sigma \models \varphi_{LTL} \]

We split the proof in two again, first assuming $\sigma \not\models \theta_e \wedge \square \rho_e$, i.e.: $\sigma \models \neg\theta_e \vee \Diamond \neg\rho_e$, in this case $\varphi_{LTL}$ is trivially satisfied. Now if $\sigma \models \theta_e \wedge \square \rho_e$ holds it should also satisfy $\theta_s$, $\square\rho_s$ and $val(\varphi)$. Since $\sigma$ is a play in $fds(C)$ then $\theta_d=(\theta_e \implies \theta_s)$ and $\rho_d=(\rho_e \implies \rho_s)$ hold, and since it also satisfies $\theta_e \wedge \square \rho_e$ we observe the following:
\[((\theta_e \implies \theta_s) \wedge \theta_e))\implies \theta_s\]
\[((\rho_e \implies \rho_s) \wedge \rho_e))\implies \rho_s\]
To show that $\sigma$ also satisfies $val(\varphi)$ we prove that there is an execution $\execution$ in $C$ that follows $\sigma$.
For a play $\sigma \in 2^{|\mathcal{V}|^{\omega}}$ we define $exec(\sigma) \in S^{\omega}$ as follows, suppose that $\sigma = \sigma_1 \sigma_2 \ldots \sigma_i \ldots$ and
$exec(\sigma)= \execution_1 \execution_2 \ldots \execution_i \ldots$, then $\execution_i = s_j \iff \sigma_i \models \varState{j}$. For each pair ($\sigma_i$,$\sigma_{i+1}$), since $\sigma \models \rho_e \wedge \rho_s$, by restriction $\rho_s$
We observe that $\sigma_i \models s_j$ implies that there exists a transition $(j, l, k)$ s.t.$\sigma_{i+1} \models s_k$ and $\sigma_{i+i} \models \delta_s(l) \wedge \bigwedge_{l' \in L \setminus \{l\}}(\neg \delta_s(l'))$, and in particular $\sigma_0 \models s_0$, from which follows that $\pi \in C$.
Since for each play $\sigma$ that satisfies $\theta_e \wedge \square \rho_e$ we have a trace $\pi$ in controller $C$, and since $C \models \varphi$ we can show that $\sigma \models val(\varphi)$.


This is proved over the syntactic construction of $\varphi$, we will only show the base case of atomic satisfaction, i.e.
$\pi \models val(fl_i) \implies \sigma \models v_{fl_i}$. Again, looking at $\gsRhoS$, $\bigwedge_{f = 1}^{|\mathcal{F}|}f_{val}(f,l)$ after the next state operator updates valuation of fluent variables according to $val(fl_i)$ at state $i+1$, proving that $\pi \models val(fl_i) \implies \sigma \models v_{fl_i}$.


