
When having to compose concurrent systems we define three different semantics that can be applied pairwise. Synchronous semantic $A ||_s B$ (Figure~\ref{fig:synchronous_composition})captures the composition of two components that share a single synchronizing event (implicit), where all participants should be able to make progress concurrently. The main motivation being digital components sharing a single clock. 
Asynchronous semantic $A ||_a B$ (Figure~\ref{fig:asynchronous_composition}) captures the interleaving interpretation of concurrency as found in LTS systems. 

\begin{figure}[h]
		\centering
	\includegraphics[scale=.4]{img/full-adder.eps}
	\caption{Full adder circuit}
	\label{fig:full_adder_circuit}
\end{figure}

A motivation for the synchronous composition can be found in the following example: a digital design consists of two 1 bit full adders working as separate units. Let $i \in \{1,2\}$ be the index of each adder and $a$ and $b$ the 1 bit entries to be added, $c\_in_i$ the incoming carry signal from another module, $s_i$ the output that represents the lower bit of the sum and $c_i$ the upper bit or carry out, then each 1 bit full adder can be modeled as a single state CLTS.  The FSP syntax would be the following:

\renewcommand{\ttdefault}{pcr}
\begin{figure}[H]
	\begin{lstlisting}[escapeinside={[*}{*]},basicstyle=\scriptsize\ttfamily,columns=flexible,mathescape=true,xleftmargin=3.0ex,keywordstyle=\textbf,morekeywords={if,while,do,else,fork,int,null, algorithm, is, input, output, return, for}]
	FULL_ADDER[i] = (<a[i],s[i]> -> FULL_ADDER[i] | <b[i],s[i]> -> FULL_ADDER[i] 
	| <c_in[i],s[i]> -> FULL_ADDER [i] | <a[i],b[i],c[i]> -> FULL_ADDER[i]
	| <a[i],c_in[i],c[i]> -> FULL_ADDER[i] | <b[i],c_in[i],c[i]> -> FULL_ADDER[i]
	| <a[i],b[i],c_in[i],s[i],c[i]> -> FULL_ADDER[i]| <> -> FULL_ADDER[i]).
\end{lstlisting}
%\caption{Game Structure to CLTS translation algorithm}
\label{fig:full_adder_fsp}
%%\vspace*{-4mm}
\MediumPicture
\end{figure}	

Applying asynchronous composition over single element labeled CLTS models ($FULL\_ADDER[1]$ $\parallel_{a}$ $FULL\_ADDER[2]$), would not properly capture the concurrent occurrence of signals, since it will not allow $<a_1,s_1,a_2,s_2>$ to happen.  

On the other hand, suppose that we are modeling the interaction of three processes $P_1$, $P_2$ and $receiver$ through a common buffer, $P_1$ produces either $a$ or $c$ and
$P_2$ produces either $d$ or $e$. $receiver$ will output a $x$ for each $a$ and a $y$ for each $d$. The FSP syntax would be the following:

\renewcommand{\ttdefault}{pcr}
\begin{figure}[H]
	\begin{lstlisting}[escapeinside={[*}{*]},basicstyle=\scriptsize\ttfamily,columns=flexible,mathescape=true,xleftmargin=3.0ex,keywordstyle=\textbf,morekeywords={if,while,do,else,fork,int,null, algorithm, is, input, output, return, for}]
	P_1 = (a->P_1 | c->P_1).
	P_2 = (d->P_2 | e->P_2).
	Receiver = (<a,x> -> Receiver | <d,y> -> Receiver | c -> Receiver | e -> Receiver).
	\end{lstlisting}
	%\caption{Game Structure to CLTS translation algorithm}
	\label{fig:receiver_fsp}
	%%\vspace*{-4mm}
	\MediumPicture
\end{figure}

Special attention is required when applying the parallel composition operator in order to recreate the system overall interaction. If synchronous semantic ($P_1\parallel_s P_2 \parallel_s receiver$) is to be applied then $receiver$ will not be able to synchronize with both $P_1$ and $P_2$ since at least one action on each component needs to be exercised. In this case, asynchronous composition ($P_1\parallel_a P_2 \parallel_a receiver$)will properly recreate the serialization of events coming from $P_1$ and $P_2$ through the buffer.

Composition semantics should be applied according the each domain, be aware that composition is not commutative if different semantics are applied for the same specification.

%Concurrent semantic $A ||_c B$ (Figure~\ref{fig:concurrent_composition}) captures the behavioral superset of the latter two. It can be used when composing two processes that may not share an implicit synchronizing event, as in the synchronous semantic, but can be observed by a third component that over samples the other two, allowing for the possibility of both concurrent an independent occurrence when observed as a composed system. A synthetic example is shown in Figure~\ref{fig:concurrent_systems}, motivation for this semantic can be found in clock domain crossing examples and micro architecture buffers.
%
%\input{composition_example}

%\begin{definition} 
%	\label{def:concurrent_composition}(\emph{Concurrent Composition})	Let \automaton{M},\automaton{N}, with $\Delta_M : S_M \times \mathcal{P}(\Sigma_M) \times S_M$, be two CLTS instances, then CLTS concurrent parallel composition is defined as \ltsComposition{M}{N}{c} where $\Delta$ is the smallest relation s.t:
%	\begin{center}
%		\begin{equation}
%		\AxiomC{$(s, l_M, s') \in \Sigma_M,(t, l_N, t') \in \Sigma_N  $}\RightLabel{$l_M \cap \Sigma_N = l_N \cap \Sigma_M$}
%		\UnaryInfC{$((s,t),l_M \cup l_N,(s',t')) \in \Delta$}
%		\DisplayProof
%		\end{equation}	
%		\begin{equation}
%		\AxiomC{$(s, l_M, s') \in \Sigma_M $}\RightLabel{$l_M \cap \Sigma_N = \emptyset$}
%		\UnaryInfC{$((s,t),l_M,(s',t))$}
%		\DisplayProof
%		\quad\quad
%		\AxiomC{$(t, l_N, t') \in \Sigma_N $}\RightLabel{$l_N \cap \Sigma_M = \emptyset$}
%		\UnaryInfC{$((s,t),l_N,(s,t'))$}
%		\DisplayProof
%		\end{equation}
%	\end{center}
%\end{definition}

In the scope of this work asynchronous composition will only be applied over CLTS instances whose transitions contain only one action per label. Asynchronous semantics follow the same rules as in the LTS case.

%\begin{definition} 
%	\label{def:asynchronous_composition}(\emph{Asynchronous Composition}) Let \automaton{M},\automaton{N}, with $\Delta_M : S_M \times \mathcal{P}(\Sigma_M) \times S_M$, be two CLTS instances, then CLTS asynchronous parallel composition is defined as \ltsComposition{M}{N}{a} where $\Delta$ is the smallest relation s.t:
%	\begin{center}
%		\begin{equation}
%		\AxiomC{$(s, l_M, s') \in \Sigma_M,(t, l_N, t') \in \Sigma_N  $}\RightLabel{$l_M \cap \Sigma_N = l_N \cap \Sigma_M \neq \emptyset$}
%		\UnaryInfC{$((s,t),l_M \cup l_N,(s',t')) \in \Delta$}
%		\DisplayProof
%		\end{equation}	
%		\begin{equation}
%		\AxiomC{$(s, l_M, s') \in \Sigma_M $}\RightLabel{$l_M \cap \Sigma_N = \emptyset$}
%		\UnaryInfC{$((s,t),l_M,(s',t))$}
%		\DisplayProof
%		\quad\quad
%		\AxiomC{$(t, l_N, t') \in \Sigma_N $}\RightLabel{$l_N \cap \Sigma_M = \emptyset$}
%		\UnaryInfC{$((s,t),l_N,(s,t'))$}
%		\DisplayProof
%		\end{equation}
%	\end{center}
%\end{definition}

\begin{definition} 
	\label{def:synchronous_composition}(\emph{Synchronous Composition}) Let \automaton{M},\automaton{N}, with $\Delta_M : S_M \times \mathcal{P}(\Sigma_M) \times S_M$, be two CLTS instances, then CLTS synchronous parallel composition is defined as \ltsComposition{M}{N}{s} where $\Delta$ is the smallest relation s.t:
	\begin{center}
		\begin{equation}
		\AxiomC{$(s, l_M, s') \in \Delta_M,(t, l_N, t') \in \Delta_N  $}\RightLabel{$l_M \cap \Sigma_N = l_N \cap \Sigma_M$}
		\UnaryInfC{$((s,t),l_M \cup l_N,(s',t')) \in \Delta$}
		\DisplayProof	
		\end{equation}	
	\end{center}
\end{definition}

%\begin{definition} 
%	Let $M_1 \ldots M_N$ be CLTS instances s.t. $M_i= (S_{i}, \Sigma_{i}, \Delta_{i}, s_{0}^{i})$ with $\Delta_i : S_i \times l \subseteq \Sigma_i \times S_i$, the concurrent parallel composition \ltsComposition{}{M_i}{} where $\Delta_i$ is the smallest relation s.t:
%	\begin{center}
%		\begin{equation}
%		\AxiomC{$\forall i,j \in 1 \ldots N, i \neq j: ((s_i, l_i, t_i) \in \Delta_i \wedge \forall a \in l_i : a \in (\Sigma_i \cap \Sigma_j) \rightarrow (a \in l_i \wedge a \in l_j)) \vee (l_i = \emptyset \wedge t_i = s_i)$}
%		\UnaryInfC{$((s_1 \ldots s_N),\cup_{i=1}^{N}l_i,(t_1 \ldots t_N)) \in \Delta$}
%		\DisplayProof
%		\end{equation}		
%	\end{center}
%\end{definition}

%\begin{figure}[ht]
%	\begin{center}
%		\input{compositionCode} 
%		\caption{Concurrent Composition Algorithm}
%		\label{fig:dfs-code}
%	\end{center}
%\end{figure}
An algorithm to apply parallel composition over a set of automata (according to a set of semantic definitions) is now presented.  The idea is to start with the composition of the initial states $(s_{0_1},\ldots,s_{0_n})$ as the only element if the $frontier$ to be explored. In subsequent iterations elements are removed and their composed transitions filtered and merged. The resulting target $(s'_1,\ldots,s'_n)$ states are pushed back to the $frontier$ for further evaluation. At every step in the exploration of a particular state $s:(s_1,\ldots,s_n)$ the cross product of the elements of the sets of outgoing transitions $\Delta_1(s_1) \times \ldots \Delta_n(s_n)$ is tested for consistency with respect to the  semantic $(type_1,\ldots,type_{n-1})$. Combinations of source transitions $\delta:(\delta_1,\ldots,\delta_n)$ are iterated depth first obtaining combination $(\delta_1,\ldots,\delta_n)$, then a linear pass over its components merges previous labels (if needed) and checks the partial resulting label $l_{1\ldots i}$  against the following properties:
\[\neg blocks(\delta_{1\ldots i})= \neg(l_{1\ldots i}\cap \Sigma_{i+1} \neq l_{i+1} \cap \Sigma_{1\ldots i}) \]
\[asynch(\delta_{1\ldots i})= \neg (l_{1\ldots i}\cap \Sigma_{i+1} = l_{i+1} \cap \Sigma_{1\ldots i}=\emptyset) \]
\[synch(\delta_{1\ldots i})= \neg (l_{1\ldots i}=\emptyset \vee l_{i+1} =\emptyset) \]
Property $\neg blocks$ should always hold, then $asynch$ and $synch$ need to be satisfied according to $type_i$ (if $type_i \neq concurrent$). As soon as a property is violated the next element $\delta':(\delta'_1,\ldots,\delta'_n)$ is evaluated, if these properties hold up to $n$ then, if $\delta_{i}:(s_i,l_i,t_i)$, transition
$((s_1,\ldots,s_n),l_{1\ldots n},(t_1,\ldots,t_n))$ is added to the composition.


\begin{figure}[ht]
	\begin{center}
		\input{compositionCode2} 
		\caption{Concurrent Composition Algorithm (closer to code version)}
		\label{fig:dfs-code2}
	\end{center}
\end{figure}

When taking fluents into consideration several valuations can be applied to the same state, because of this a mechanism needs to be defined to disambiguate which valuation is correct at any given step of a trace that follows the behavior of an automaton.
In the context of this work the approach is to extend the states of the automaton with its fluents' valuations. Starting with the initial state the automaton is updated applying the following mapping:

\[
eval(s_0) = {Initially_0,\ldots,Initially_k}\\
eval(v,l) = {update(l,i) | i \in 0\ldots k}
\]
\[
update(l,i)	=  \begin{cases}
\top & \text{if } \exists \alpha \in I_i: l \subseteq \alpha \\
\bot & \text{if } \exists \beta \in T_i: l \subseteq \beta \\
v_i & \text{if } \nexists \gamma \in I_i \cup T_i: l \subseteq \gamma \\
\end{cases}
\]