\section{Motivation}\label{sec:motivation}
We motivate and informally introduce relevant concepts by discussing a small example while also illustrating what we consider to be the complementary nature 
of both the presented approach and that of ~\cite{DBLP:conf/hvc/KonighoferHB10}. Suppose that the engineer is working on a specification consisting of two environmental boolean variables $x_1$ and $x_2$ and one system variable $y$. Variable $x_2$ (initially false) is required to swap its value at each step of the execution, while $x_1$ remains free. The value of $y$ is set at the start and kept fixed throughout the execution.
It is assumed that $x_1$ will hold true infinitely often while $x_1 \wedge x_2 \wedge y$ is also required to be satisfied infinitely often. This is the set of LTL formulae of the specification, with $\theta$ being the initial condition, $\rho_e$ the environmental safety restriction, $\varphi_e$ the liveness assumption and $\varphi_s$ the liveness guarantee:
\begin{center}
	\begin{tabular}{ r c l }
		$\theta$& $=$ &$\neg x_1 \wedge \neg x_2$\\
		$\rho_e$& $=$ &$\square(x_2 \leftrightarrow \bigcirc(\neg x_2))$\\
		$\rho_s$& $=$ &$\square(y \leftrightarrow \bigcirc(y))$\\		
		$\varphi_e$& $=$ &$\square \Diamond x_1$\\
		$\varphi_s$& $=$ &$\square \Diamond (x_1 \wedge x_2 \wedge y)$\\
	\end{tabular}
\end{center}

The automaton induced from this set of formulae is depicted in Fig. ~\ref{fig:konig_original_plant_2_clts}. At this point, the specification is not realizable because the environment can set $x_1$ to true only when $x_2$ is down, thus honoring the environmental assumption while avoiding the system to reach the winning valuation $x_1 \wedge x_2 \wedge y$. The minimization presented in ~\cite{DBLP:conf/hvc/KonighoferHB10} removes $\rho_e$ since it is unnecessary for the environment to swap $x_2$ regularly in order to win the (non) realizability game. This approach can be characterized as a syntactic minimization, whose purpose is to help the engineer when viewing the specification (in particular the safety part describing the behavior of the plant) as a set of LTL formulae. This approach, nonetheless, yields the automaton depicted in Fig. ~\ref{fig:konig_original_plant_k_2} which is, in fact, more complex in terms of its explicit behavior. Our approach is designed to simplify the semantic view of the specification, producing the automaton depicted in Fig. ~\ref{fig:konig_original_plant_c_2}. 

The syntactic minimization should help the engineer to focus on a smaller set of formulae while diagnosing the non realizability cause (in this case the too weak assumption $\varphi_e$) by getting rid of the irrelevant element $\rho_e$. Our approach simplifies the specification semantically instead, reducing the relevant behavior and showing that it is possible for the environment to avoid state 2 by never allowing $x_1$ and $x_2$ to happen simultaneously, while at the same time not restricting the system below its original capabilities. Notice that if we were allowed to add the assumption that both environmental variables occur simultaneously infinitely often ($\rho'_s = \square \Diamond x_1 \wedge x_2$) the specification would be realizable and choosing to raise $y$ at the beginning would be sufficient in order to guarantee our goal, as shown in Fig. ~\ref{fig:konig_strategy_2}. After fixing $y$ to true the environment can move freely as long as it visits state 2 infinitely often. If the engineer has this behavior in mind as her design intent, it should be easy to see that in the semantic minimization the desired state is unreachable, hopefully guiding her to the strengthening of the assumption.  In Fig. ~\ref{fig:konig_composition_2} we show the synchronous composition of the aforementioned strategy with our minimization. Note that after letting the system raise $y$ state 1 is visited only once and then the execution keeps moving between states 2 and 3 in order to keep the value of $x_2$ oscillating.
%\begin{figure}[bt]
%	\centering
%	\SmallPicture
%	%\ShowFrame
%	\VCDraw{
%		\begin{VCPicture}{(-4,-2.5)(4,9.5)}
%			\SetEdgeLabelScale{1.4}
%			\StateVar[0:\overline{x_1 x_2} y]{(-3,6)}{0}
%			\StateVar[1:x_1 x_2 y]{(0,8)}{1}
%			\StateVar[2:x_1 \overline{x_2} y]{(3,6)}{2}
%			\StateVar[3:\overline{x_1} x_2 y]{(0,4)}{3} 
%			\StateVar[4:\overline{x_1 x_2 y}]{(-3,0)}{4}			
%			\StateVar[5:x_1 x_2 \overline{y}]{(0,2)}{5}
%			\StateVar[6:x_1 \overline{x_2 y}]{(3,0)}{6}
%			\StateVar[7:\overline{x_1} x_2 \overline{y}]{(0,-2)}{7}   			  
%			\Initial[w]{0}
%			\Initial[w]{4}	
%			\ArcR{0}{1}{}
%			\ArcR{1}{0}{}
%			\ArcR{1}{2}{}						
%			\ArcR{2}{1}{}
%			\ArcR{2}{3}{}        
%			\ArcR{3}{2}{}
%			\ArcR{3}{0}{}
%			\ArcR{0}{3}{}
%			\ArcR{4}{5}{}
%			\ArcR{5}{4}{}
%			\ArcR{5}{6}{}						
%			\ArcR{6}{5}{}
%			\ArcR{6}{7}{}        
%			\ArcR{7}{6}{}
%			\ArcR{7}{4}{}
%			\ArcR{4}{7}{}			
%		\end{VCPicture}
%	}
%	\caption{Original Plant}
%\label{fig:konig_original_plant_2}
%\MediumPicture
%\end{figure}
\begin{figure}[bt]
\centering
\SmallPicture
%\ShowFrame
	\VCDraw{
	\begin{VCPicture}{(-4,-2.5)(4,9.5)}
		\SetEdgeLabelScale{1.4}
		\State[0]{(-5,3)}{init}
		\State[1]{(-2.5,3)}{init_e}		
		\State[2]{(-1.5,6)}{0}
		\State[3]{(1.5,8)}{1}
		\State[4]{(4.5,6)}{2}
		\State[5]{(1.5,4)}{3} 
		\State[6]{(-1.5,0)}{4}			
		\State[7]{(1.5,2)}{5}
		\State[8]{(4.5,0)}{6}
		\State[9]{(1.5,-2)}{7} 			  
		\Initial[w]{init}
		\EdgeL{init}{init_e}{\overline{x_1 x_2}}
		\ArcL{init_e}{0}{y}
		\ArcR{init_e}{4}{\overline{y}}	
		\ArcR{0}{1}{}\LabelL[.5]{x_1 x_2}
		\LArcR[.6]{1}{0}{\overline{x_1 x_2}}
		\ArcR{1}{2}{}\LabelL[.5]{\overline{x_2}}
		\LArcR[.6]{2}{1}{x_2}
		\ArcR{2}{3}{}\LabelL[.5]{\overline{x_1}x_2}
		\LArcR[.6]{3}{2}{x_1\overline{x_2}}
		\ArcR{3}{0}{}\LabelL[.5]{\overline{x_2}}
		\LArcR[.6]{0}{3}{x_2}
		\ArcR{4}{5}{}\LabelL[.5]{x_1 x_2}
		\LArcR[.6]{5}{4}{\overline{x_1 x_2}}
		\ArcR{5}{6}{}\LabelL[.5]{\overline{x_2}}
		\LArcR[.6]{6}{5}{x_2}
		\ArcR{6}{7}{}\LabelL[.5]{\overline{x_1}x_2}
		\LArcR[.6]{7}{6}{x_1\overline{x_2}}
		\ArcR{7}{4}{}\LabelL[.5]{\overline{x_2}}
		\LArcR[.6]{4}{7}{x_2}	
	\end{VCPicture}
}
	\caption{Original Plant}
	\label{fig:konig_original_plant_2_clts}
	\MediumPicture
\end{figure}
\begin{figure}[bt]
	\centering
	\SmallPicture
	%\ShowFrame
	\VCDraw{
	\begin{VCPicture}{(-4,-3.8)(4,10.3)}
		\SetEdgeLabelScale{1.4}
		\State[0]{(-5,3)}{init}
		\State[1]{(-2.5,3)}{init_e}		
		\State[2]{(-1.5,6.8)}{0}
		\State[3]{(1.5,8.8)}{1}
		\State[4]{(4.5,6.8)}{2}
		\State[5]{(1.5,4.8)}{3} 
		\State[6]{(-1.5,-.8)}{4}			
		\State[7]{(1.5,1.2)}{5}
		\State[8]{(4.5,-.8)}{6}
		\State[9]{(1.5,-2.8)}{7} 			  
		\Initial[w]{init}
		\LoopW{0}{}
		\LoopN{1}{}
		\LoopE{2}{}
		\LoopS{3}{}				
		\LoopW{4}{}
		\LoopN{5}{}
		\LoopE{6}{}
		\LoopS{7}{}			
		\EdgeL{init}{init_e}{\overline{x_1 x_2}}
		\ArcL{init_e}{0}{y}
		\ArcR{init_e}{4}{\overline{y}}	
		\VArcR{arcangle=10,ncurv=.9}{0}{1}{}\LabelL[.5]{x_1 x_2}
		\VArcR{arcangle=-55,ncurv=.9}{1}{0}{\overline{x_1 x_2}}
		\VArcR{arcangle=10,ncurv=.9}{1}{2}{}\LabelL[.5]{\overline{x_2}}
		\VArcR{arcangle=-55,ncurv=.9}{2}{1}{x_2}
		\VArcR{arcangle=10,ncurv=.9}{2}{3}{}\LabelL[.5]{\overline{x_1}x_2}
		\VArcR{arcangle=-55,ncurv=.9}{3}{2}{x_1\overline{x_2}}
		\VArcR{arcangle=10,ncurv=.9}{3}{0}{}\LabelL[.5]{\overline{x_2}}
		\VArcR{arcangle=-55,ncurv=.9}{0}{3}{x_2}
		\VArcR{arcangle=10,ncurv=.9}{4}{5}{}\LabelL[.5]{x_1 x_2}
		\VArcR{arcangle=-55,ncurv=.9}{5}{4}{\overline{x_1 x_2}}
		\VArcR{arcangle=10,ncurv=.9}{5}{6}{}\LabelL[.5]{\overline{x_2}}
		\VArcR{arcangle=-55,ncurv=.9}{6}{5}{x_2}
		\VArcR{arcangle=10,ncurv=.9}{6}{7}{}\LabelL[.5]{\overline{x_1}x_2}
		\VArcR{arcangle=-55,ncurv=.9}{7}{6}{x_1\overline{x_2}}
		\VArcR{arcangle=10,ncurv=.9}{7}{4}{}\LabelL[.5]{\overline{x_2}}
		\VArcR{arcangle=-50,ncurv=.9}{4}{7}{x_2}	
		\VArcL[.7]{arcangle=15,ncurv=.4}{0}{2}{x_1}
		\VArcL[.7]{arcangle=15,ncurv=.4}{2}{0}{\overline{x_1}}
		\VArcL[.7]{arcangle=15,ncurv=.4}{1}{3}{x_1}
		\VArcL[.7]{arcangle=15,ncurv=.4}{3}{1}{\overline{x_1}}
		\VArcL[.7]{arcangle=15,ncurv=.4}{4}{6}{x_1}
		\VArcL[.7]{arcangle=15,ncurv=.4}{6}{4}{\overline{x_1}}
		\VArcL[.7]{arcangle=15,ncurv=.4}{5}{7}{x_1}
		\VArcL[.7]{arcangle=15,ncurv=.4}{7}{5}{\overline{x_1}}		
	\end{VCPicture}
}	
	\caption{Minimization according to KÃ¶nighoefer}
	\label{fig:konig_original_plant_k_2}
	\MediumPicture
\end{figure}
\begin{figure}[bt]
	\centering
	\SmallPicture
	%\ShowFrame
	\VCDraw{
	\begin{VCPicture}{(-4,.5)(4,8.5)}
		\SetEdgeLabelScale{1.4}
		\State[0]{(-5,4)}{init}
		\State[1]{(-2.5,4)}{init_e}		
		\State[2]{(-1.5,6)}{0}
		\State[3]{(1.5,8)}{1}
		\State[4]{(4.5,6)}{2}
		\State[5]{(1.5,4)}{3} 
		\State[6]{(-1.5,2)}{4}			
		\State[7]{(1.5,1)}{5}
		\State[8]{(4.5,1)}{6}			  
		\Initial[w]{init}
		\EdgeL{init}{init_e}{\overline{x_1 x_2}}
		\ArcL{init_e}{0}{y}
		\ArcR{init_e}{4}{\overline{y}}	
		\ArcL{0}{1}{}\LabelL[.5]{x_1 x_2}
		\ArcL{1}{2}{}\LabelL[.5]{\overline{x_2}}
		\LArcR[.5]{2}{3}{\overline{x_1}x_2}
		\LArcR[.6]{3}{2}{x_1\overline{x_2}}
		\ArcR{4}{5}{}\LabelL[.5]{x_1 x_2}
		\LArcR[.6]{6}{5}{x_2}
		\LArcR[.6]{5}{6}{\overline{x_2}}
	\end{VCPicture}
}
	\caption{Behavior minimization}
	\label{fig:konig_original_plant_c_2}
	\MediumPicture
\end{figure}
\begin{figure}[bt]
	\centering
	\SmallPicture
	%\ShowFrame
	\VCDraw{
		\begin{VCPicture}{(-4,3.5)(4,9.5)}
			\SetEdgeLabelScale{1.4}
			\State[0]{(-5,6)}{init}
			\State[1]{(-3,6)}{init_e}		
			\State[2]{(-1,6)}{0}
			\State[3]{(2,8)}{1}
			\State[4]{(5,6)}{2}
			\State[5]{(2,4)}{3} 		  
			\Initial[w]{init}
			\EdgeL{init}{init_e}{\overline{x_1 x_2}}
			\EdgeL{init_e}{0}{y}
			\ArcR{0}{1}{}\LabelL[.5]{x_1 x_2}
			\LArcR[.6]{1}{0}{\overline{x_1 x_2}}
			\ArcR{1}{2}{}\LabelL[.5]{\overline{x_2}}
			\LArcR[.6]{2}{1}{x_2}
			\ArcR{2}{3}{}\LabelL[.5]{\overline{x_1}x_2}
			\LArcR[.6]{3}{2}{x_1\overline{x_2}}
			\ArcR{3}{0}{}\LabelL[.5]{\overline{x_2}}
			\LArcR[.6]{0}{3}{x_2}	
		\end{VCPicture}
	}
	\caption{Realizable version strategy}
	\label{fig:konig_strategy_2}
	\MediumPicture
\end{figure}
\begin{figure}[bt]
	\centering
	\SmallPicture
	%\ShowFrame
	\VCDraw{
	\begin{VCPicture}{(-4,3.5)(4,9.5)}
		\SetEdgeLabelScale{1.4}
		\State[0]{(-5,6)}{init}
		\State[1]{(-3,6)}{init_e}		
		\State[2]{(-1,6)}{0}
		\State[3]{(2,8)}{1}
		\State[4]{(5,6)}{2}
		\State[5]{(2,4)}{3} 		  
		\Initial[w]{init}
		\EdgeL{init}{init_e}{\overline{x_1 x_2}}
		\EdgeL{init_e}{0}{y}
		\ArcL{0}{1}{x_1 x_2}
		\ArcL{1}{2}{\overline{x_2}}
		\ArcR{2}{3}{}\LabelL[.5]{\overline{x_1}x_2}
		\LArcR[.6]{3}{2}{x_1\overline{x_2}}
	\end{VCPicture}
}
	\caption{Composition of the strategy with the minimization}
	\label{fig:konig_composition_2}
	\MediumPicture
\end{figure}
%\clearpage
%
%
%We introduce a simple example to illustrate what we consider to be the complementary nature 
%of both the presented approach and that of ~\cite{DBLP:conf/hvc/KonighoferHB10}. Suppose that the engineer is working on a specification consisting of two environmental boolean variables $x_1$ and $x_2$ and one system variable $y$. $x_2$ (initially false) is required to swap its valuation at each step of the execution, while $x_1$ remains free. The value of $y$ is derived from the conjunction of the two environmental variables.
%It is assumed that $x_1$ will be set to true infinitely often while $y$ is required to also be satisfied infinitely often. The set of LTL formulae corresponding to this specification is as follow: 
%\begin{center}
%	\begin{tabular}{ r c l }
%	$\theta_e$& $=$ &$\neg x_1 \wedge \neg x_2$\\
%	$\theta_s$& $=$ &$\neg y$\\
%	$\rho_e$& $=$ &$\square(x_2 \leftrightarrow \bigcirc(\neg x_2))$\\
%	$\rho_s$& $=$ &$\square((x_1 \wedge x_2) \leftrightarrow y)$\\
%	$\varphi_e$& $=$ &$\square \Diamond x_1$\\
%	$\varphi_s$& $=$ &$\square \Diamond y$\\
%\end{tabular}
%\end{center}
%
%The automaton induced from this set of formulae is depicted in Fig. ~\ref{fig:konig_original_plant}. The specification is not realizable because the environment can set $x_1$ to true only when $x_2$ is down, thus honoring the environmental assumption. The minimization presented in ~\cite{DBLP:conf/hvc/KonighoferHB10} removes $\rho_e$ since it is unnecessary for the environment to swap $x_2$ regularly in order to win the (non) realizability game. This approach can be characterized as a syntactic minimization, whose purpose is to help the engineer when viewing the specification (in particular the safety part describing the behavior of the plant) as a set of LTL formulae. This approach, nonetheless, yields the automaton depicted in Fig. ~\ref{fig:konig_original_plant_k} which is, in fact, more complex behavior-wise. Our approach is designed to simplify the semantic view of the specification, producing the automaton depicted in Fig. ~\ref{fig:konig_original_plant_c}. 
%
%The syntactic minimization should help the engineer to focus on a smaller set of formulae while diagnosing the non realizability cause (in this case the too weak assumption $\varphi_e$) by getting rid of the irrelevant element $\rho_e$. Our approach simplifes the specification semantically, reducing the relevant behavior and showing that it is possible for the environment to avoid state 2 by never allowing $x_1$ and $x_2$ to happen simultaneously. If we were allowed to add the assumption that both environmental variables occur infinitely often ($\rho'_s = \square \Diamond x_1 \wedge x_2$) the specification would be realizable and the plant as is would be a proper controller, since it allows the environment to move freely as long as it visits state 2 infinitely often. If the engineer has this behavior in mind as her design intent, it should be easy for her to see that in our minimization the desired state is unreachable, hopefully guiding her to the strengthening of the assumption.  
%\newpage
%\begin{figure}[bt]
%\centering
%\SmallPicture
%%\ShowFrame
%\VCDraw{
%	\begin{VCPicture}{(-4,-2.5)(4,2.5)}
%		\SetEdgeLabelScale{1.4}
%		\StateVar[0:\overline{x_1 x_2 y}]{(-3,0)}{1}
%		\StateVar[2:x_1 x_2 y]{(0,-2)}{2}
%		\StateVar[1:\overline{x_1} x_2 \overline{y}]{(3,0)}{3}
%		\StateVar[3:x_1 \overline{x_2 y}]{(0,2)}{6}        
%		\Initial[w]{1}
%		\ArcR{1}{2}{}
%		\ArcR{2}{1}{}
%		\ArcR{6}{1}{}        
%		\ArcR{1}{6}{}
%		\ArcR{2}{3}{}
%		\ArcR{3}{2}{}
%		\ArcR{3}{6}{}
%		\ArcR{6}{3}{}
%	\end{VCPicture}
%}
%\caption{Original Plant}
%\label{fig:konig_original_plant}
%\MediumPicture
%\end{figure}
%\begin{figure}[bt]
%	\centering
%	\SmallPicture
%	%\ShowFrame
%	\VCDraw{
%		\begin{VCPicture}{(-4,-3)(4,3)}
%			\SetEdgeLabelScale{1.4}
%			\StateVar[0:\overline{x_1 x_2 y}]{(-3,0)}{1}
%			\StateVar[2:x_1 x_2 y]{(0,-2)}{2}
%			\StateVar[1:\overline{x_1} x_2 \overline{y}]{(3,0)}{3}
%			\StateVar[3:x_1 \overline{x_2 y}]{(0,2)}{6}        
%			\Initial[n]{1}
%			\LoopW{1}{}
%			\LoopN{6}{}
%			\LoopE{3}{}
%			\LoopS{2}{}
%			\ArcR{1}{2}{}
%			\EdgeL{2}{1}{}
%			\ArcR{1}{3}{}
%			\ArcR{3}{1}{}
%			\ArcR{6}{1}{}        
%			\EdgeL{1}{6}{}
%			\ArcR{2}{3}{}
%			\EdgeL{3}{2}{}
%			\ArcR{2}{6}{}
%			\ArcR{6}{2}{}
%			\ArcR{3}{6}{}
%			\EdgeL{6}{3}{}
%		\end{VCPicture}
%	}
%	\caption{Minimization according to KÃ¶nighoefer}
%	\label{fig:konig_original_plant_k}
%	\MediumPicture
%\end{figure}
%\begin{figure}[bt]
%	\centering
%	\SmallPicture
%	%\ShowFrame
%	\VCDraw{
%		\begin{VCPicture}{(-4,-3)(4,3)}
%			\SetEdgeLabelScale{1.4}
%			\StateVar[0:\overline{x_1 x_2 y}]{(-3,0)}{1}
%			\StateVar[2:x_1 x_2 y]{(0,-2)}{2}
%			\StateVar[1:\overline{x_1} x_2 \overline{y}]{(3,0)}{3}
%			\StateVar[3:x_1 \overline{x_2 y}]{(0,2)}{6}        
%			\Initial[w]{1}       
%			\EdgeL{1}{6}{}
%			\ArcR{3}{6}{}
%			\ArcR{6}{3}{}
%		\end{VCPicture}
%	}
%	\caption{Behavior minimization}
%	\label{fig:konig_original_plant_c}
%	\MediumPicture
%\end{figure}
%\clearpage
%We motivate and informally introduce relevant concepts by discussing a small example inspired by~\cite{DBLP:conf/vmcai/PitermanPS06}. Suppose an engineer is writing the specification for an industrial
%controller that needs to coordinate communication between various devices consuming data from different sensors via a shared bus according to the scheduling policy defined by an arbiter. 
%A device acting as a master will raise a bus access requirement ($req$) 
%%on the related bus input line 
%to communicate with a specific sensor acting as a slave. 
%The arbiter can then either grant access to the device ($grant$) or give the bus
%to another master ($\overline{grant}$). For the latter case, the device denied permission will have to wait for the slave currently using the bus to raise a
%ready signal ($hready$) indicating that it has finished operation.  Only then
%will the device issue another requirement.  If access is granted then the device
%will wait either for a slave confirmation ($hready$) or a $timeout$ event.
%After the slave has finished operation the device will start to process the
%received information ($process$). Should the slave issue a timeout message, a reset will be triggered ($reset$) to try and restore normal operation.  
%The initial environment specification $E$, including safety assumptions and safety goals, is presented in Figure~\ref{fig:req_grant}, where
%solid lines indicate non controllable actions and dotted lines indicate
%controlled actions.  Non controllable actions are those that the environment
%can trigger while controlled actions are triggered by the system. 
%\begin{figure}[bt]
%\centering
%\SmallPicture
%%\ShowFrame
%\VCDraw{
%    \begin{VCPicture}{(-4,-1.5)(4,2.3)}
%        \SetEdgeLabelScale{1.4}
%        \State[1]{(-3,0)}{1}
%        \State[2]{(0,0)}{2}
%        \State[3]{(3,1)}{3}
%        \State[4]{(-0.5,3)}{4}
%        \State[6]{(0,1.5)}{6}        
%        \State[5]{(3,-1)}{5}
%		\Initial[w]{1}
%        \ChgEdgeLineStyle{dashed} %\EdgeLineDouble
%        %\ChgEdgeLineWidth{1.5}
%        \EdgeL{1}{2}{req}
%        \ArcR[.3]{6}{1}{reset}        
%        \VArcR{arcangle=-30}{4}{1}{process}        
%        %\RstEdgeLineWidth{1}
%        \RstEdgeLineStyle %\EdgeLineSimple
%        \EdgeL{2}{3}{grant}
%        \EdgeL[.75]{2}{5}{\overline{grant}}
%        %\VArcR{arcangle=-20}{3}{6}{timeout}
%        \ArcR[.6]{3}{6}{timeout}
%        \ArcL{5}{1}{hready}
%        \VArcR{arcangle=-30}{3}{4}{hready}
%    \end{VCPicture}
%}
%\caption{Bus Access example ($E$)}
%\label{fig:req_grant}
%%%\vspace*{-4mm}
%\MediumPicture
%\end{figure}
%\begin{figure}[bt]
%\centering
%\SmallPicture
%%\ShowFrame
%\VCDraw{
%    \begin{VCPicture}{(-4,-1.5)(4,2)}
%        \SetEdgeLabelScale{1.4}
%        \State[1]{(-3,0)}{1}
%        \State[2]{(0,-1)}{2}
%        \State[3]{(3,0)}{3}
%        \State[6]{(0,1)}{6}        
%		\Initial[w]{1}
%        \ChgEdgeLineStyle{dashed} %\EdgeLineDouble
%        %\ChgEdgeLineWidth{1.5}
%        \ArcR{1}{2}{req}
%        \ArcR{6}{1}{reset}        
%        %\RstEdgeLineWidth{1}
%        \RstEdgeLineStyle %\EdgeLineSimple
%        \ArcR{2}{3}{grant}
%        %\VArcR{arcangle=-20}{3}{6}{timeout}
%        \ArcR{3}{6}{timeout}
%    \end{VCPicture}
%}
%\caption{Minimized Bus Access ($E_1$)}
%\label{fig:req_grant_sub_1}
%%\vspace*{-4mm}
%\MediumPicture
%\end{figure}
%\begin{figure}[bt]
%\centering
%\SmallPicture
%%\ShowFrame
%\VCDraw{
%    \begin{VCPicture}{(-4,-1.5)(4,2)}
%        \SetEdgeLabelScale{1.4}
%        \State[1]{(-3,0)}{1}
%        \State[2]{(0,0)}{2}
%        \State[3]{(3,1)}{3}
%        \State[6]{(0,1.5)}{6}        
%        \State[5]{(3,-1)}{5}
%		\Initial[w]{1}
%        \ChgEdgeLineStyle{dashed} %\EdgeLineDouble
%        %\ChgEdgeLineWidth{1.5}
%        \EdgeL{1}{2}{req}
%        \ArcR[.3]{6}{1}{reset}        
%        %\RstEdgeLineWidth{1}
%        \RstEdgeLineStyle %\EdgeLineSimple
%        \EdgeL{2}{3}{grant}
%        \EdgeL[.75]{2}{5}{\overline{grant}}
%        %\VArcR{arcangle=-20}{3}{6}{timeout}
%        \ArcR[.7]{3}{6}{timeout}
%        \ArcL{5}{1}{hready}
%    \end{VCPicture}
%}
%\caption{Minimized Bus Access ($E_2$)}
%\label{fig:req_grant_sub_2}
%%\vspace*{-4mm}
%\MediumPicture
%\end{figure}
%
%
%The goal of continually processing data from the board is captured
%by the LTL liveness formula $\square\Diamond process$.  The assumption
%that access to the bus will always eventually be granted to the device
%is captured by the liveness formula $\square\Diamond grant$.
% Note that without further assumptions the environment is able to
% systematically produce $timeout$ actions even after granting the device access
% to the bus.  These two choices, picking $grant$ at state 2 and then
% $timeout$ at state 3 conform a winning strategy for the environment. In other
% words, no matter what the system does, the environment, by making these two
% choices always prevents the system goals from being achieved.
% 
%The  specification $E_{1}$ in Figure~\ref{fig:req_grant_sub_1} is a subgraph of $E$, describing an environment with strictly less behavior than that of $E$. Furthermore, the winning environment strategy for specification $E_1$ is also a winning environment strategy in $E$. Indeed,  $E_1$ cannot be further reduced while satisfying this strategy preserving property. Thus, $E_1$ can be thought of as a slice of the original environment specification that has removed behavior that is irrelevant with respect to a cause for unrealizability.
%
%Assume that after analyzing this first unrealizability cause another assumption is added, forcing the environment to produce
%$hready$ infinitely often ($\square\Diamond hready$) hoping to reach state 4,
%thus realizing the goal.  It turns out that even after adding this
%new assumption the specification remains unrealizable:  The environment
%can avoid state 4 if it keeps track of the most recently satisfied assumption.
%It can first grant access to the device and then produce a $timeout$. 
%This will be the first cycle of its strategy, then it will deny access
% ($\overline{grant}$) and start over again.  This alternating strategy will allow the environment
% to fulfill its assumptions (producing $grant$ in the first cycle
% and $hready$ in the second) while avoiding to produce the expected
% outcome.  The LTS in Figure
% ~\ref{fig:req_grant_sub_2} represents a minimal slice of the original specification $E$ that captures the winning strategy of the environment. 
% 
% 
%
% %  Note that we are
% %trying to progressively fix the specification with the information
% %provided by our behavior minimization feedback . $E_2$ is of complimentary value
% %with respect to the counter strategy since it presents a more compact 
% %representation of the conflict (avoiding memory induced unrolling)
% %that is also canonical (since it does not need to fix an order for the
% %satisfaction of the assumptions on behalf of the environment).
% 
% \begin{comment}
%  
%Our technique is in fact quiet different, in terms of behavior, to what is
%achieved by minimizing the set of LTL formulae in a declarative specification.
%To exemplify the difference, and the complementation between the declarative
%and the behavior minimization we introduce a synthetic case where an engineer
%wants to specify a zero triggered latch mechanism. The initial specification
%involves only two signals: $x$ representing a single boolean input and $y$ the only
%boolean output.  The idea is that the output should be kept constantly up 
%once a zero boolean value has been fed to the system.
%Before this $y$ must remain low.  
%The specification is written as the conjunction of four LTL 
%formulae as presented in table \ref{table:d-ff-spec}. 
%Following the definitions from \cite{DBLP:conf/vmcai/PitermanPS06} $\theta_s$ stands for
%an initial system formula, $\rho_s$ for a safety system formula and 
%$\varphi_s$ for a system liveness formula.
%The \textit{Initial condition} formula 
%fixes the initial value for the output signal,
%\textit{Wait for negative trigger} keeps the value of $y$ down as long as the input
%is up and the output value has not yet been raised, \textit{Latch} keeps the 
%output up after the initial raise and the \texttt{GR(1)} \textit{Goal} is to 
%always eventually produce an output ($\square\Diamond(y)$).  After running our automated
%translation we produced the LTS representation of the \textit{Game Structure}
%definition.  We get the behavior depicted in Figure \ref{fig:fig.neg-trigger-latch-behavior}.
%The $\uparrow$ suffix after a signal name means the the value is being raised ($x\uparrow$),
%$\downarrow$ consequently means that value is being lowered ($x\downarrow$).  A $tick$ event
%is added to show when the values can be kept constant at the current time step.
%\begin{center}
% %\vspace*{-4mm}
%\begin{table}[h]
%  \begin{tabular}{ l  c  l }
%	Name & Type & Requirement \\
%    \hline
%    Initial condition & $\theta_s$ & $y = 0$\\
%    Wait for negative trigger & $\rho_s$ &$\square((x \wedge \neg y) \rightarrow \Circle(\neg y) )$ \\
%    Latch & $\rho_s$ &$\square (y \rightarrow \Circle(y))$ \\   
%    Goal &  $\varphi_s$ & $\square\Diamond(y)$\\
%  \end{tabular}
%  \caption{Zero triggered latch specification}
%  \label{table:d-ff-spec}
% \end{table}
% %\vspace*{-12mm}
%\end{center}
%We wrote this specification in \texttt{RATSY}, run the minimization presented in
%\cite{DBLP:conf/hvc/KonighoferHB10} (where the \textit{Latch} requirement was
%considered irrelevant and removed) and then translated the minimized specification
%to produce the LTS depicted in Figure 
%\ref{fig:fig.neg-trigger-latch-behavior-formula-minimization}.  Understanding the specification
%in terms of the conjunction of formulas we can see that the $Latch$ requirement is irrelevant
%to the unrealizability cause since even if we allow the system to lower $y$ after its initial
%raise, no output would be produced if the input is kept up.  Removing a formula is, in fact,
%relaxing the behavior, this is expressed in the double lined states and transitions 
%present in Figure \ref{fig:fig.neg-trigger-latch-behavior-formula-minimization}.  
%We can see that the transitions added express the new behavior where the system is allowed
%to lower $y$ after being raised.  Let us note that removing a formula means relaxing, 
%thus augmenting, the behavior of the system.
%\begin{figure}[bt]
%\centering
%\SmallPicture
%%\ShowFrame
%\VCDraw{
%    \begin{VCPicture}{(-4,-5)(4,4)}
%        \SetEdgeLabelScale{1.4}
%        \State[1]{(0,3)}{1}
%        \State[2]{(-3,2)}{2}        
%        \State[3]{(-3,0)}{3}
%        \State[4]{(3,-2)}{4}        
%        \State[5]{(-3,-2)}{5}                
%        \State[6]{(-3,-4)}{6}                        
%        \State[7]{(3,2)}{7}                                
%        \State[8]{(3,0)}{8}                                        
%		\Initial[n]{1}
%		\EdgeL{1}{2}{$x$\downarrow}
%		\EdgeR{1}{7}{$x$\uparrow}		
%		\EdgeR{8}{3}{$x$\downarrow}								
%		\LoopW{3}{$tick$}
%		\LoopE{8}{$tick$}		
%		\LoopW{6}{$tick$}		
%		\EdgeR{3}{4}{$x$\uparrow}
%		\ArcR{5}{6}{$x$\uparrow}
%		\ArcR{6}{5}{$x$\downarrow}		
%        \ChgEdgeLineStyle{dashed} 
%		\EdgeR{4}{6}{$y$\uparrow}		
%		\EdgeL{2}{3}{$y$\downarrow}				
%		\EdgeL{7}{8}{$y$\downarrow}						
%		\EdgeR{3}{5}{$y$\uparrow}
%		\EdgeR{4}{8}{$tick$}		
%    \end{VCPicture}
%}
%%\vspace*{-2mm}
%\caption{Zero triggered latch behavior.}
%\label{fig:fig.neg-trigger-latch-behavior}
%%\vspace*{-8mm}
%\MediumPicture
%\end{figure}
%
%\begin{figure}[bt]
%\centering
%\SmallPicture
%%\ShowFrame
%\VCDraw{
%    \begin{VCPicture}{(-4,-6)(4,5)}
%        \SetEdgeLabelScale{1.4}
%        \State[1]{(0,3)}{1}
%        \State[2]{(-3,2)}{2}        
%        \State[3]{(-3,0)}{3}
%        \State[4]{(1,-1)}{4}        
%        \State[5]{(-3,-2)}{5}                
%        \State[6]{(-3,-4)}{6}                        
%        \State[7]{(3,2)}{7}                                
%        \State[8]{(3,0)}{8}                                        
%        \StateLineDouble
%		\State[9]{(1,-2.5)}{9}                         
%        \State[10]{(-1,-2.5)}{10}                             
%		\Initial[n]{1}
%		\EdgeL{1}{2}{$x$\downarrow}
%		\EdgeR{1}{7}{$x$\uparrow}		
%		\ArcR{8}{3}{$x$\downarrow}								
%		\LoopW{3}{$tick$}
%		\LoopE{8}{$tick$}		
%		\EdgeL[.8]{3}{4}{$x$\uparrow}
%		\ArcR{5}{6}{$x$\uparrow}
%		\ArcR{6}{5}{$x$\downarrow}	
%		\EdgeLineDouble		
%		\LoopS{9}{$tick$}	
%		\ArcR[.3]{6}{9}{$tick$}
%		\EdgeR{9}{10}{$x$\downarrow}
%		\EdgeLineSimple
%        \ChgEdgeLineStyle{dashed} 
%		\EdgeL{2}{3}{$y$\downarrow}				
%		\EdgeL{7}{8}{$y$\downarrow}						
%		\ArcR{3}{5}{$y$\uparrow}
%		\EdgeL{4}{8}{$tick$}		
%		\EdgeLineDouble
%		\EdgeR{10}{5}{$tick$}		
%		\ArcR[.2]{10}{3}{$y$\downarrow}						
%		\ArcR{4}{9}{$y$\uparrow}		
%		\ArcR{9}{8}{$y$\downarrow}		
%		\ArcR{5}{3}{$y$\downarrow}
%		\VArcR{arcangle=-60,ncurv=1}{6}{8}{$y$\downarrow}				
%    \end{VCPicture}
%}
%%\vspace*{-8mm}
%\caption{Zero trig. latch formula based minimization.}
%\label{fig:fig.neg-trigger-latch-behavior-formula-minimization}
%%\vspace*{-4mm}
%\MediumPicture
%\end{figure}
%We are looking at the same problem expressed from two 
%different directions, thus making impossible a direct comparison of
%the techniques.  One of our claims is that our approach is in
%fact complimentary to that of the declarative minimization.
%Our minimization produces the LTS depicted in Figure 
%\ref{fig:fig.neg-trigger-latch-behavior-minimization}, where it
%shows that the environment can easily win by playing to keep
%$x$ up.  
%It is important to note that when minimizing the control problem we must
%keep it unrealizable while allowing the environment to have
%a winning strategy that works in both the minimized and the original
%control problem.
%\begin{figure}[bt]
%\centering
%\SmallPicture
%%\ShowFrame
%\VCDraw{
%    \begin{VCPicture}{(-5,-2)(5,2)}
%        \SetEdgeLabelScale{1.4}
%        \State[1]{(-3,0)}{1}
%        \State[2]{(0,0)}{2}        
%        \State[3]{(3,0)}{3}
%		\Initial[w]{1}
%		\EdgeL{1}{2}{$x$\uparrow}
%		\LoopE{3}{$tick$}		
%        \ChgEdgeLineStyle{dashed} 
%		\EdgeL{2}{3}{$y$\downarrow}				
%    \end{VCPicture}
%}
%%\vspace*{-8mm}
%\caption{Zero trig. latch behavior based minimization.}
%\label{fig:fig.neg-trigger-latch-behavior-minimization}
%%\vspace*{-4mm}
%\MediumPicture
%\end{figure}
%In both the declarative and the behavior-based approaches the
%idea is that we are aiding the engineer in understanding the
%cause on unrealizability.  If we think in terms of specification repair,
%in this particular case if she were to add
%a new assumption (\textit{input will eventually fall}), either as
%$\square\Diamond(\neg x)$ or $\Diamond(\neg x)$ the specification
%will become realizable.
%In the next sections we will show how to automatically build a minimal sub-LTS that preserves a winning strategy for the environment (which is a cause of unrealizability).
%%\input{declarativeVsOperative}
%%\input{latchExample}
%
%
%\end{comment}
 