\newpage 
\section{Validation}
The extent to which the technique serves it purpose is defined by its soundness, efficiency and, more importantly, information, understood as the ability to guide the engineer while writing a non trivial formal specification. The presented diagnosis should help by pointing out the causes of non realizability (expressed in a behavioral implicit language) that may appear while progressively gathering knowledge and building a complete and precise model.

The measure of information our technique may provide should ultimately be related to the impact it can have on the overall specification process, in particular how clear it is for the engineer  to interpret the diagnosis in terms of amount of data presented and its relevance in relation to the non realizability cause. The unavailability of skilled professionals and the amount of time and effort required to prepare a considerable set of external subjects to the point where they would be able to write non trivial formal specifications renders the perspective of a controlled experiment with external engineers writing specifications from scratch unfeasible. On the other hand, it is also impossible to propose a direct comparison with similar techniques, since, for instance, in ~\cite{DBLP:conf/hvc/KonighoferHB10} the minimization is applied on the set of environmental safety formulas, which in fact increments the volume of the plant when presented as an automaton, and in ~\cite{DBLP:conf/sigsoft/KuventMR17} a simplification of the symbolic counter strategy is presented as a LTS composed of attractors and trap states. We think that our technique adds a complimentary view to the non realizability diagnosis problem.

We now explain two of the metrics used to quantitatively evaluate our technique. The first metric is relative minimization volume ($v_{\mathcal{U}}$), defined as the size of the minimized plant against the original instance ($|\Delta_{E'}|/|\Delta_{E}|$). The number of transitions is used as the representation of absolute volume since it is the defining parameter in the complexity of the synthesis algorithms. The other metric we compute is minimization volume relative to the controller volume ($v_{\mathcal{C}}=|\Delta_{E'}|/|\Delta_{C}|$). The controller $C$ is the automaton representation of the strategy for the realizable version of each specification. The rationale behind this is that the size of the controller is a good proxy for the volume of the engineer's design intent in terms of concrete behavior. The motivation for taking the controller as a proxy of volume is that sometimes an ongoing specification is under defined, with weaker conditions than it will eventually have when reaching realizability. We expect for our minimization to be at least comparable to the controller in terms of volume.


The validation reported in this section is guided by two main concerns.  This first is the degree to which the initial control problem is reduced and the computational cost involved. The second is if the minimization offers insight into non realizability causes.
In order to avoid bias, we prioritized using non realizable specifications present in the existing benchmarks and literature.

%refs 
The Generic Buffer case study was taken from~\cite{DBLP:conf/hvc/KonighoferHB10}, the Lift Controller comes from ~\cite{DBLP:conf/fmcad/AlurMT13}, Collector is part of the SYNTCOMP competition ~\cite{SYNTCOMP} benchmark and the exploration robot case was adapted from ~\cite{DBLP:journals/corr/abs-2001-07678}.

%tool support - tool/translation/diagnosis
The diagnosis technique was implemented in a new tool that accepts specifications expressed as both LTL formulas or FSP constructs and operates internally on CLTS structures. Each case study was written in its original syntax, for signal based specifications we used LTL formulas (as presented in ~\cite{Bloem:2012}), and for those initially described using process-like syntax we used CFSP. This tool was written from scratch with the intention to model, verify and synthesize reactive systems over enumerative models in an effective fashion. Bear in mind that for each specification the diagnosis runs a number of synthesis checks (each one having its particular time complexity) linear in time in relation to the number of transitions of the original plant.
Prior to this work the only feedback given to the user  when specifying an non realizable problem over an enumerative model was binary, either the problem was realizable or it was not.
he extension builds a minimized non realizable version of the environment that can then be exported to different formats and inspected through various methods including animations and visualization of the state space.

In the following we report quantitatively on all case studies to show the degree to which the initial control problem is reduced and the computational cost involved. We also briefly explain the case studies and provide an interpretation of what we think are the hints extracted from the diagnosis. 

%technical text
The quantitative results of our experiments are shown in table 
\ref{table:quantitative-results} and were run on an 
\texttt{Intel\textsuperscript{\textregistered} Core\textsuperscript{\texttrademark}
 i7-8565U} CPU with 8 processors running at 1.80GHz frequency
with 32 Gb of RAM memory over \texttt{Ubuntu 20.04 (Linux 5.4 kernel release)}.
Total time taken by the diagnosis algorithm is measured in seconds and
labeled as \emph{Diag. time(s)}, \emph{Diag. steps} shows the number of steps the diagnosis algorithm had to take to yield a minimal plant, this can be thought as de maximum depth of recursion reached while exploring the semi-lattice of alternating Sub-LTS structures.  The values in column $|\varphi_e + \varphi_s|$ are the sum of environmental and system liveness formulae, $|\Delta_{E}|$ the number of transitions in the original plant, $|\Delta_{E'}|$ the number of transitions in the minimization,
, $|\Delta_{E'}|/|\Delta_{E}|$ is the relation of the minimization volume against the original plant, , $|\Delta_{C}|$ the number of transitions in the controller for the realizable specification,
, $|\Delta_{E'}|/|\Delta_{C}|$ is the relation of the minimization volume against the controller.

\begin{table*}
	\resizebox{\textwidth}{!} {
\input{../experimental_setting/tmp_results/experimental_data.tex}
}
  \caption{Quantitative results for minimized plants}
  \label{table:quantitative-results}
 \end{table*}
\begin{figure}[bt]
	\centering
	\SmallPicture
\includegraphics[width=0.3\textwidth, angle=-90]{../experimental_setting/tmp_results/min_ctrl_vs_min_pct.ps}
	\vspace*{-2mm}
	\caption{Minimization controllability vs. minimization percentage.}
	\label{fig:min_ctr_vs_min_pct}
	\vspace*{-4mm}
	\MediumPicture
\end{figure}
\begin{figure}[bt]
	\centering
	\SmallPicture
	\includegraphics[width=0.3\textwidth, angle=-90]{../experimental_setting/tmp_results/size_vs_diag_time.ps}
	\vspace*{-2mm}
	\caption{Minimization size vs. diagnosis time.}
	\label{fig:size_vs_diag_time}
	\vspace*{-4mm}
	\MediumPicture
\end{figure}
%DD complexity, DFS reduction

%\subsection{Optimization}
%\subsection{Test Cases}
%\subsection{Experimental Framework}
%\subsection{Results}


%update quantitative analysis and explain graphs
From the results it is possible to argue that the minimization technique can be applied to control problems of similar size to those reported in the literature. 
%In addition, it is possible to observe, as expected, that the  that spatial and temporal limitation behave linearly with respect to the realizability query. 
In addition, it can be seen that the technique can achieve a significant reduction in terms of states and transitions.



\subsection{Modified Lift Controller}
Another example that has been evaluated is that
of the Modified Lift Controller from 
\cite{DBLP:conf/fmcad/AlurMT13} first presented in
its realizable version in 
\cite{DBLP:journals/jcss/BloemJPPS12}.
In the original version a lift controller should serve
several floors.  It has a button sensor for each floor 
controlled by the environment.  There is an additional 
restriction that allows the lift to move up only if there
is a pending request in one of the floors 
($\square \Diamond (b_j \implies f_j)$), and another that
forces the system to visit the first floor infinitely
often if no button was pressed.\\
In the modified version from ~\cite{DBLP:conf/fmcad/AlurMT13} a new set of system liveness 
requirements is added, where the system should 
visit each floor infinitely often ($\square \Diamond f_j$).


The problem here is that this requirement collides with
the restriction that the lift will not move up if there
is no pending request.\\
We run the minimization over a simplified two floors
specifications and produced the LTS depicted in Figure
\ref{fig:lift-controller-minimization}.
It shows that after initial variable setting on behalf of the
environment (states 1 to 3) the system is free to choose 
opposite values for the initial floor (either start at
floor 1, states 3 to 5, or start at the second floor,
states 3 to 8), if it chooses to start at the first floor
the environment leaves the $b1, b2$ signals down, falsifying
the $\square \Diamond f_j$ requirement, since it cannot 
go up to visit the second floor unless $b2$ is up.  On the
other hand if the system chooses the second floor as the
initial configuration the environment keeps waiting until
the lift descends to win by letting the signals down.
The system is forced to descend eventually to satisfy
the restriction that it should visit the first floor when
$b1$ and $b2$ are down.  In this example we have to do
some more interpretation after the LTS has been minimized,
but we think this is a reasonable expectation.  The minimization removed 
84 states out of the 95 in the original specification, so
even if the engineer has to correlate liveness assumptions
with the minimized LTS 
the technique proves itself helpful by hiding
irrelevant behavior.\\
Going back to \cite{DBLP:conf/fmcad/AlurMT13} we see that our
slice is consistent with the diagnosis presented by the authors
where they say that \emph{(\ldots)A counter-strategy for the
environment is to always keep all $b_i$'s low(\ldots)}.
Indeed, this counter strategy is captured by the minimized 
LTS depicted in Figures~\ref{fig:lift-controller-minimization}.
% strategy for the environment can be expressed
%n this case as $f_{1}^{\neg \varphi}(s_1)= b1 \downarrow$,
% $f_{1}^{\neg \varphi}(s_2)= b2 \downarrow$.
\begin{figure}[bt]
\centering
\SmallPicture
%\ShowFrame
\VCDraw{
    \begin{VCPicture}{(-6,-3.5)(6,3.5)}
        \SetEdgeLabelScale{1.4}
        \State[1]{(-6,2)}{1}
        \State[2]{(-2,2)}{2}
        \State[3]{(2,2)}{3}
        \State[6]{(6,2)}{6}
        \State[4]{(-2,0)}{4}        
        \State[5]{(-6,-2)}{5}        
        \State[8]{(2,-2)}{8}        
        \State[7]{(6,-2)}{7}        
		\Initial[w]{1}
        \EdgeL{1}{2}{b1 \downarrow}		
        \EdgeL{2}{3}{b2 \downarrow}		        
		\LoopW{5}{tick}                
		\LoopE{7}{tick}                
        \ChgEdgeLineStyle{dashed} %\EdgeLineDouble		
        \EdgeL{3}{6}{f1 \downarrow}		                
        \EdgeR{3}{4}{f1 \uparrow}		                       
        \EdgeR{4}{5}{f2 \downarrow}                               	
		\EdgeL{6}{7}{f2 \uparrow}                		
		\EdgeR{7}{8}{f1 \uparrow}         		
		\EdgeR{8}{5}{f2 \downarrow}         				
    \end{VCPicture}
}
\vspace*{-2mm}
\caption{Modified Lift Controller minimization.}
\label{fig:lift-controller-minimization}
\vspace*{-4mm}
\MediumPicture
\end{figure}
%system allows noncontrollable cycle to avoid deadlock
%\input{t_strong_fairness_validation}

\subsection{Collector}

\subsection{Exploration Robot}

\subsection{Generalized Buffer (GenBuf)}
Non realizable specifications of the Generalized Buffer Case Study~\cite{DBLP:journals/entcs/BloemGJPPW07} were studied in~\cite{DBLP:conf/fmcad/KonighoferHB09}.  
%Original LTL specifications were automatically translated to produce the expected LTS input.  
The original specification was introduced by 
IBM with their Rulebase verification tool~\cite{beer1996rulebase}.
It describes a family of buffers that transmit data from $n$ senders
$Sender_0,Sender_1$$,\ldots$ $,Sender_n$ to two receivers $Receiver_0$ and
$Receiver_1$.  Data is received from senders in a random order and should be
delivered to the receivers in round-robin order.  
It contains a handshake protocol to communicate with each sender/receiver device
by exchanging $StoB\_REQ(i) \leftrightarrow BtoS\_ACK(i)$ messages on the senders side
and $BtoR\_REQ(j) \leftrightarrow RtoB\_ACK(j)$ on the receivers.  
A controller should arbitrate between the senders and the receivers to
accomplish proper communication through a four slot FIFO queue.
Several restrictions and assumptions are declared in order
to ensure consistent behavior (e.g. \emph{G2: No request should be immediately
acknowledged since it is valid at least one step 
after the assertion of request}).\\

\begin{figure}[bt]
\centering
\SmallPicture
%\ShowFrame
\VCDraw{
    \begin{VCPicture}{(-6,-3.5)(6,3.5)}
        \SetEdgeLabelScale{1.4}
        \State[1]{(-7.5,0)}{1}
        \State[80]{(3,2)}{80}
        \State[79]{(6,2)}{79}
        \State[81]{(1.5,0)}{81}        
        \State[82]{(3,-2)}{82}        
        \State[83]{(6,-2)}{83}        
        \State[78]{(7.5,0)}{78}                
		\Initial[w]{1}
        \ArcR{81}{82}{tick\_e}		
        \ArcR{78}{79}{tick\_e}		                                        
        \ChgEdgeLineStyle{dashed} %\EdgeLineDouble				
        \ArcR{82}{83}{SLC0\uparrow}		                
        \ArcR{83}{78}{tick\_s}		                        
        \ArcR{79}{78}{tick\_s}		                                
        \ArcR{79}{80}{SLC0\downarrow}		                                      
        \ArcR{82}{81}{tick\_s}		        
        \ArcR[.35]{80}{81}{tick\_s}        
        \ZZEdgeL{1}{81}{\ldots StoB\_REQ0\uparrow \ldots BtoR\_REQ0\uparrow \ldots}	        
    \end{VCPicture}
}
\vspace*{-2mm}
\caption{GenBuf (missing assumption) Terminal Set.}
\label{fig:genbuf-terminal-set}
\vspace*{-4mm}
\MediumPicture
\end{figure}

We studied the three non-realizable specifications of GenBuf discussed in~\cite{DBLP:conf/fmcad/KonighoferHB09}. 
The goal is captured by the LTL formula $\square\Diamond($ $StoB\_REQ0  \leftrightarrow$ $BtoS\_ACK0))$.
 In the first the authors consider removing the assumption 
that expresses that always eventually if a request to read data
has been sent from the controller to $Receiver_0$ ($BtoR\_REQ0$) then
an acknowledge will be issued ($RtoB\_ACK0$).  
The minimized environment decreased 80\%
(from 10964 to 2235 states) and, amongst other things, excluded all actions related with $Receiver_1$,
since they are irrelevant to the environment's strategy.
In the minimized LTS we identified one terminal set
depicted in Figure~\ref{fig:genbuf-terminal-set} in which one guarantee is being 
neglected infinitely often: 
  In the trace leading to the terminal set
the buffer sends \\$BtoR\_REQ0$ message to $Receiver_0$ but
never gets the expected acknowledge ($RtoB\_ACK0$), thus
not being able to produce an acknowledge for the sender.  This
diagnosis should point the engineer in the direction to
enforce the specification by restricting the environment to always
eventually produce an acknowledge message for each requirement
sent to the receivers.\\
The second variation studied in~\cite{DBLP:conf/fmcad/KonighoferHB09}  incorporated the goal 
$\square \Diamond$ $(\neg EMPTY$ $\wedge$ $\neg DEQ)$.
The minimized environment decreased 92\%
(from 10964 to 850 states)
with only one strongly connected component at which point the buffer remains empty and the environment keeps exchanging the value of the
signal $SLC$ and never requests the bus ($StoB\_REQ(i)$), thus preventing the controller to achieve the new goal. This tells us that the problem is the lack of an assumption that states that the environment must always eventually achieve $ENQ$ thus lowering the $EMTPY$ signal. 
\\
The final variation analyzed in ~\cite{DBLP:conf/fmcad/KonighoferHB09} restricts specification by
adding a new safety requirement $\square \neg ENQ$. This already reduces the size of the 
problem significantly (39 states) leaving little room for minimization (resulting in 26 states). Indeed, in both the original and minimized environment LTS it is straightforward to visualize the deadlock state which is reached after the first
$BtoS\_ACK(i)$ message. This acknowledgement is required to be followed by raising the $ENQ$ signal which would violate the new requirement. 


