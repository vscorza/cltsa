TODO:
- document manually run cses
- write soundness/completeness demo for gr(1) translations
- review composition times
- run hardware cases
	- review/document ltl -> CLTS translation
		- check state size, running two specs sequentially
	- explain manual composition/synthesis/ltl translation of small examples
	- GR(1) over CLTS formalism
	- behavior minimization based diagnosis over CLTS
	- diagnose GENBUF with 2 clients
	- improve fluents encoding (superset of labels is too expensive)
	- run genbuf 2, 4, 10 clients
	- run amba 2, 4, 10 clients
	- document obdd
- implement fluent set parsing
- implement fluent consistency check
- solve aliases in states e.g. S[i:R] = S_p[i], S_p[i:R] = (s->S_2[i]).
- implement relabeling and hiding (use half adder to full adder example)

PRINT CODE
enscript -2r -T=1 --line-numbers -p out.ps --font="Courier6" --highlight=c  automaton_context.c


SPRINT2
- aparte de <a,b,c> introducir >a,b,c< que define concurrencia dÃ©bil, puede transicionar con un subconj de estos
- parse assertions, goals
- implement reachability
SPRINT3
- yacc and automaton_context -> define a way to index concurrent labels, it is not the same to index particular labels (thus adding new transitions
		for each index) than to add index to concurrent labels (adding new transitions on the whole concurrent set)
- evaluation of expressions with free variables should be able to evaluate fluent valuations and constants, maybe even a random value generator with constant seed
range R = 1..2
A = ( <a, b[i:R], c[j:R]> -> A). should translate to A = ( {<a,b.1,c.1>, <a,b.2,c.1>, <a,b.1,c.2>, <a,b.2,c.2>}->A).
A = ( <a, b[i], c[i]>[i:R] -> A). should translate to A = ( {<a,b.1,c.1>, <a,b.2,c.2>}->A).
- add feedback for errors
SPRINTX
- partitioned composition, everything not on the frontier can be downloaded to a bucket list of files in order to free the memory
- keep indexes and other information in the automaton structure (concolyc style)
- merge obdd and lts
