TODO:
=====
- re-run tests
- review papers Synthesis of AMBA AHB from Formal Specification:A Case Study, shield_synthesis, symbolic repair
- write amba version
- run tests for genbuf 4, 5, 6
- improve reports
	- write as being loaded from rmakrdon
	- automatize report pipeline
- review papers gr_1_star, performance_heuristics for gr1
- diagnose mutation over small parameters, produce hypothesis, scale both hypothesis and parameter to see if it holds
- build konighoefer comparison graph over non_real_1_k.fsp
- de efectividad hacer alguna mención a la implementación y la linealidad, comparar con ejemplos comparables
- explicar ejemplos nuevos
- controller || E' 
	- write files, import ctrol, diag, compose, export
	- report size and structure
	- show diff on composition
- for non-realizability reduce diagnosis to single liveness goal not being satisfied
- write amba client version from synthesis of amba ahb from formal specification
- run tests with dd, linear, dd wo last_partition optimization, goal minimization
- java client
	- improve report loading from java client
	- allow several specs to be loaded concurrently
	- syntax highlight strings
	- undo/redo 
	- signals view as complement to automaton
- add exception when FIXED_SIGNALS_COUNT or BITVECTOR_ENTRY_SIZE is not enough, add parameters to make
- see if following changes are worth the worry
	- add transition disabling to speed up minimization time (should do enabled_in_degree and enabled_out_degree)
		- change seems to be too expensive in terms of refactoring to be worthy, since it may not prove useful once automaton copy is not as frequent
	- in dd minimization keep track of mins. tested as tested: bitvector -> 0 not tested, 1 realizable, 2 non realizable
		should be able to only keep as many in terms of the dd step
		- check current minimization bitvector m with previous minimization bitvector p
			if at any step p_i & m_i != p_i skip p (was not less or equal than m)
			if check completes then use p result for m
	
- further improve reports
	- report separate synthesis cases individually within same file
	- report composition times independently from model build	
- explore controllable simplification
	- hide queue in genbuf (hide signals, tau reduction)
	- review konighoefer work
- implement formulaic labels, [!lock && !start]G2 = ( lock && start -> G2), 
	will create an automaton by initializing variables as defined in [v] and defining transitions by those who satisfhy
	rho(v, v', s, s')
- graph the way removed transitions increment in the lineal minimization
- split functionality into several files, refactor
- synthesis improvements
	- take bigger values first on synthesis
	- take noncontrollable states first on synthesis
	- keep inf scc over rankings
- compare against konighoefer and jvts systems, write experimental claim
- implement fluent consistency check
- allow to define buchi fluent based on accepting state, for instance for automaton based properties in genbuf
- implement IS_REALIZABLE(gr1). on parser
POST PHD
========
- develop mixed structures 
	- EROBDD (enumerative ROBDD) first node determines current state
	  s -[s1] -> s_1 | ... | s -[sk] -> s_k, the seconde node
	  (not sure if should be last one) determines next state,for each transition
	  s_i -> s_j where there are signal changes those are added, if signal
	  v is set between s_i,s_j then v is false in V and true in V',
	  recreate this o EROBDD s_i, s' branch, then the EROBDD is minimized, first
	  as OBDDs then, for equivalent state nodes, merges are represented as 
	  intervals S_{1,4,[7,12]} and so on
	- define apply:EROBDD x OBDD -> EROBDD (where an OBDD is restricted by
	  an EROBDD)
	- define EROBDD valuations
	- write definitions and lemmas
	- implement and test against existing examples
- [automata-reporter]
	- integration of cfsp editor (parsing error location info)
	- partial automaton exploration for big automata (jung adaptation with outgoing dashed labels)
	- alla RATSY signal reporting for automaton
- document obdd
- adapt examples from https://www.doulos.com/knowhow/psl/
- solve aliases in states e.g. S[i:R] = S_p[i], S_p[i:R] = (s->S_2[i]).
- implement relabeling and hiding (use half adder to full adder example)
- implement symbolic synthesis
- implement diagnosis of maximal realizable ltl spec (maximal set of ltl formula s.t. at least one liveness is satisfied)

Meetings
========
2019-10-16 meeting
- How does CLTS control problem compares to LTS cp? Does every CLTS control problem can be encoded as LTS?
- Where is the benefit when solving hardware specs? Is it in the formalism or the tool?
- What happens with the language of the composition? does the components languages are included in the target?
- Explain the motivation behind the availability of two composition semantics, motivate it as allowing encapsulation of synch component asynchronous composed with another (or viceversa)


PRINT CODE
==========
enscript -2r -T=1 --line-numbers -p out.ps --font="Courier6" --highlight=c  automaton_context.c


BACKLOG
=======
SPRINT2
- aparte de <a,b,c> introducir >a,b,c< que define concurrencia débil, puede transicionar con un subconj de estos
- implement reachability
SPRINT3
- yacc and automaton_context -> define a way to index concurrent labels, it is not the same to index particular labels (thus adding new transitions
		for each index) than to add index to concurrent labels (adding new transitions on the whole concurrent set)
- evaluation of expressions with free variables should be able to evaluate fluent valuations and constants, maybe even a random value generator with constant seed
range R = 1..2
A = ( <a, b[i:R], c[j:R]> -> A). should translate to A = ( {<a,b.1,c.1>, <a,b.2,c.1>, <a,b.1,c.2>, <a,b.2,c.2>}->A).
A = ( <a, b[i], c[i]>[i:R] -> A). should translate to A = ( {<a,b.1,c.1>, <a,b.2,c.2>}->A).
- add feedback for errors
SPRINTX
- partitioned composition, everything not on the frontier can be downloaded to a bucket list of files in order to free the memory
- keep indexes and other information in the automaton structure (concolyc style)
