TODO:
=====
- meeting	
	- improve reports
		- automatize report pipeline
			- add script to change chmod +x
			- share params between sh files ($1, $n)
		- add readme for experimental data
		- write rmd consistent with validation
	- reproductability
		- test everything on a docker image or vm				
	- examples
		- write amba version from Synthesis of AMBA AHB from Formal Specification:A Case Study
		- write examples from symbolic repair paper
		- ivy (kenneth mcmillan)
			- add leader election/multi paxos example (https://www.discotec.org/2020/invited#kenneth-mcmillan)
			- risc v memory coherence
		- check spectra (maoz) repository for unrealizable specs
		- review https://www.cl.cam.ac.uk/~sf502/regressions/rmem/help.html for examples
		- update values and validation section
		- run tests for genbuf 4, 5, 6
	- review papers gr_1_star, performance_heuristics for gr1		
	- review minimal assumption refinement gr1 and synthesizing adaptive test stategies papers

- after paper
	- for non-realizability reduce diagnosis to single liveness goal not being satisfied
	- run tests with dd, linear, dd wo last_partition optimization, goal minimization
	- java client
		- improve report loading from java client (automatically load exports)
		- allow several specs to be loaded concurrently (tabs)
		- syntax highlight strings
		- undo/redo 
		- signals view as complement to automaton
	- add exception when FIXED_SIGNALS_COUNT or BITVECTOR_ENTRY_SIZE is not enough, add parameters to make
	- see if following changes are worth the worry
		- add transition disabling to speed up minimization time (should do enabled_in_degree and enabled_out_degree)
			- change seems to be too expensive in terms of refactoring to be worthy, since it may not prove useful once automaton copy is not as frequent
		- in dd minimization keep track of mins. tested as tested: bitvector -> 0 not tested, 1 realizable, 2 non realizable
			should be able to only keep as many in terms of the dd step
			- check current minimization bitvector m with previous minimization bitvector p
				if at any step p_i & m_i != p_i skip p (was not less or equal than m)
				if check completes then use p result for m

	- see if following changes are worth the worry
		- further improve reports
			- report separate synthesis cases individually within same file
			- report composition times independently from model build	
	- jvts for clts
	- explore controllable simplification
		- hide queue in genbuf (hide signals, tau reduction)
		- review konighoefer work
	- implement formulaic labels, [!lock && !start]G2 = ( lock && start -> G2), 
		will create an automaton by initializing variables as defined in [v] and defining transitions by those who satisfhy
		rho(v, v', s, s')
	- graph the way removed transitions increment in the lineal minimization
	- split functionality into several files, refactor
	- synthesis improvements
		- take bigger values first on synthesis
		- take noncontrollable states first on synthesis
		- keep inf scc over rankings
	- compare against konighoefer and jvts systems, write experimental claim
	- implement fluent consistency check
	- allow to define buchi fluent based on accepting state, for instance for automaton based properties in genbuf
	- implement IS_REALIZABLE(gr1). on parser
	- review and relate gamma sat notion from symbolic repair with non trivial controllers, add check, compare to mtsa
	- diagnose mutation over small parameters, produce hypothesis, scale both hypothesis and parameter to see if it holds
POST PHD
========
- develop mixed structures 
	- EROBDD (enumerative ROBDD) first node determines current state
	  s -[s1] -> s_1 | ... | s -[sk] -> s_k, the seconde node
	  (not sure if should be last one) determines next state,for each transition
	  s_i -> s_j where there are signal changes those are added, if signal
	  v is set between s_i,s_j then v is false in V and true in V',
	  recreate this o EROBDD s_i, s' branch, then the EROBDD is minimized, first
	  as OBDDs then, for equivalent state nodes, merges are represented as 
	  intervals S_{1,4,[7,12]} and so on
	- define apply:EROBDD x OBDD -> EROBDD (where an OBDD is restricted by
	  an EROBDD)
	- define EROBDD valuations
	- write definitions and lemmas
	- implement and test against existing examples
- [automata-reporter]
	- integration of cfsp editor (parsing error location info)
	- partial automaton exploration for big automata (jung adaptation with outgoing dashed labels)
	- alla RATSY signal reporting for automaton
- document obdd
- adapt examples from https://www.doulos.com/knowhow/psl/
- solve aliases in states e.g. S[i:R] = S_p[i], S_p[i:R] = (s->S_2[i]).
- implement relabeling and hiding (use half adder to full adder example)
- implement symbolic synthesis
- implement diagnosis of maximal realizable ltl spec (maximal set of ltl formula s.t. at least one liveness is satisfied)
- aparte de <a,b,c> introducir >a,b,c< que define concurrencia dÃ©bil, puede transicionar con un subconj de estos
- implement reachability
- yacc and automaton_context -> define a way to index concurrent labels, it is not the same to index particular labels (thus adding new transitions
		for each index) than to add index to concurrent labels (adding new transitions on the whole concurrent set)
- evaluation of expressions with free variables should be able to evaluate fluent valuations and constants, maybe even a random value generator with constant seed
range R = 1..2
A = ( <a, b[i:R], c[j:R]> -> A). should translate to A = ( {<a,b.1,c.1>, <a,b.2,c.1>, <a,b.1,c.2>, <a,b.2,c.2>}->A).
A = ( <a, b[i], c[i]>[i:R] -> A). should translate to A = ( {<a,b.1,c.1>, <a,b.2,c.2>}->A).
- add feedback for errors
- partitioned composition, everything not on the frontier can be downloaded to a bucket list of files in order to free the memory
- keep indexes and other information in the automaton structure (concolyc style)

Meetings
========
2019-10-16 meeting
- How does CLTS control problem compares to LTS cp? Does every CLTS control problem can be encoded as LTS?
- Where is the benefit when solving hardware specs? Is it in the formalism or the tool?
- What happens with the language of the composition? does the components languages are included in the target?
- Explain the motivation behind the availability of two composition semantics, motivate it as allowing encapsulation of synch component asynchronous composed with another (or viceversa)
