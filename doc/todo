TODO:
SPRINT1
- convetir valuations en un array plano de tamaÃ±o (transitions_size * ctx->fluents_count) y luego resolver aritmetica de indice, apply valuations to states (|f| directive to parse compose with valuations, i.e. get game)
- implement gr1
- review and document code (particualarly compose)
- fluents transitions should be applied to superset of alphabet
SPRINT2
- parse assertions, goals
- parse safety ltl
- check compatibility with fluents when composing
- implement reachability
SPRINT3
- yacc and automaton_context -> define a way to index concurrent labels, it is not the same to index particular labels (thus adding new transitions
		for each index) than to add index to concurrent labels (adding new transitions on the whole concurrent set)
- evaluation of expressions with free variables should be able to evaluate fluent valuations and constants, maybe even a random value generator with constant seed
range R = 1..2
A = ( <a, b[i:R], c[j:R]> -> A). should translate to A = ( {<a,b.1,c.1>, <a,b.2,c.1>, <a,b.1,c.2>, <a,b.2,c.2>}->A).
A = ( <a, b[i], c[i]>[i:R] -> A). should translate to A = ( {<a,b.1,c.1>, <a,b.2,c.2>}->A).
- add feedback for errors
SPRINTX
- keep indexes and other information in the automaton structure (concolyc style)
- merge obdd and lts
