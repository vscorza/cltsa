TODO:
=====
- build test data
	X design values
		X times (model build, composition, synthesis x each step)
		X alphabet size, guarantees assumptions size, original states/(controllable)transitions, minimization states/(controllable)transitions x each step
		X C || E' size
		X report for dd and for linear search
	- report values
		- extend automaton_automata_context_create_from_syntax with reporting (search method, file destination, controller against E'  and writing)
			X file destination
			X search method selection (dd, linear, both)
			X controller || E' (provide controllable fsp, retrieve controller, compose against E', report size and resulting structure)
			- write selected values, search method included
		X extend run_parse_test_local
		- add run_tests parameter to cltsa with list of tests
		- test functionality
		
	- add report to linear minimization
	- write missing params to results
	- integrate with main
**********************	
	struct timeval tval_before, tval_after, tval_ltl_model_build_result,
		tval_model_build_result, tval_composition_result, tval_synthesis_result,
		tval_minimization_result;
	uint32_t results_minimization_steps, results_alphabet_size, results_guarantees_count,
		results_assumptions_count, results_plant_states, results_plant_transitions,
		results_minimization_states, results_minimization_transitions,
		results_plant_controllable_transitions, results_minimization_controllable_transitions;
	if(is_diagnosis != 0){
		experimental_results = fopen(results_filename, "w");
		if (experimental_results == NULL){
			printf("Error opening file!\n");
			return false;
		}
		fprintf(experimental_results, "name\trealizable\tltl_model_build_time\tmodel_build_time\tcomposition_time\t" \
				"synthesis_time\tdiagnosis_time\tdiagnosis_steps\talphabet_size\tguarantees_count\t" \
				"assumptions_count\tplant_states\tplant_transitions\tminimization_states\tminimizatoin_transitions\t" \
				"plant_controllable_transitions\tminimization_controllable_transitions\tsearch_method\n");
	}

	gettimeofday(&tval_before, NULL);
	gettimeofday(&tval_after, NULL);
	timersub(&tval_after, &tval_before, &tval_result);
	printf("Time elapsed: %ld.%06ld\n", (long int)tval_result.tv_sec, (long int)tval_result.tv_usec);
******************
	
	- run tests
	- generate report
	- write missing test cases
	- generate table
		- decide on whether to use r + markup or python
	- generate plots
		- minimization (original size x minimization %) (general, by type of fault)
		- controllable % x minimization %
		
- computar tiempo y agregar columna de C || E'
- profile genbuf 2
- write amba version
- run tests for genbuf 5, 6
- improve reports
	- report separate synthesis cases individually within same file
	- report composition times independently from model build
	- report realizability individually
- de efectividad hacer alguna mención a la implementación y la linealidad, comparar con ejemplos comparables
- explicar ejemplos nuevos
- armar ejemplo que compare nuestra tecnica con konighoefer y maoz
- revisar diag. de genbuf_1_no_automaton con Ass. G_True
- next deliverable
	- review konighoefer numbers
	- implement mutations on existing examples
		- remove assumption
		- add non controllable transition
		- remove controllable transition
		- mutate assumption formula using operators
		- mutate goal formula using operators
		- add conjuction of goals as new goal
	- review relation between minimization, original plant and controller either on structure or syntax
	- reason about general diagnosis 
	- diagnose mutation over small parameters, produce hypothesis, scale both hypothesis and parameter to see if it holds
- explore controllable simplification
	- hide queue in genbuf (hide signals, tau reduction)
	- review konighoefer work
- implement formulaic labels, [!lock && !start]G2 = ( lock && start -> G2), 
	will create an automaton by initializing variables as defined in [v] and defining transitions by those who satisfhy
	rho(v, v', s, s')
- graph the way removed transitions increment in the lineal minimization
- split functionality into several files, refactor
- synthesis improvements
	- take bigger values first on synthesis
	- take noncontrollable states first on synthesis
	- keep inf scc over rankings
- compare against konighoefer and jvts systems, write experimental claim
- implement fluent consistency check
- implement IS_REALIZABLE(gr1). on parser
POST PHD
========
- develop mixed structures 
	- EROBDD (enumerative ROBDD) first node determines current state
	  s -[s1] -> s_1 | ... | s -[sk] -> s_k, the seconde node
	  (not sure if should be last one) determines next state,for each transition
	  s_i -> s_j where there are signal changes those are added, if signal
	  v is set between s_i,s_j then v is false in V and true in V',
	  recreate this o EROBDD s_i, s' branch, then the EROBDD is minimized, first
	  as OBDDs then, for equivalent state nodes, merges are represented as 
	  intervals S_{1,4,[7,12]} and so on
	- define apply:EROBDD x OBDD -> EROBDD (where an OBDD is restricted by
	  an EROBDD)
	- define EROBDD valuations
	- write definitions and lemmas
	- implement and test against existing examples
- [automata-reporter]
	- integration of cfsp editor (parsing error location info)
	- partial automaton exploration for big automata (jung adaptation with outgoing dashed labels)
	- alla RATSY signal reporting for automaton
- document obdd
- adapt examples from https://www.doulos.com/knowhow/psl/
- solve aliases in states e.g. S[i:R] = S_p[i], S_p[i:R] = (s->S_2[i]).
- implement relabeling and hiding (use half adder to full adder example)
- implement symbolic synthesis
- implement diagnosis of maximal realizable ltl spec (maximal set of ltl formula s.t. at least one liveness is satisfied)

Meetings
========
2019-10-16 meeting
- How does CLTS control problem compares to LTS cp? Does every CLTS control problem can be encoded as LTS?
- Where is the benefit when solving hardware specs? Is it in the formalism or the tool?
- What happens with the language of the composition? does the components languages are included in the target?
- Explain the motivation behind the availability of two composition semantics, motivate it as allowing encapsulation of synch component asynchronous composed with another (or viceversa)


PRINT CODE
==========
enscript -2r -T=1 --line-numbers -p out.ps --font="Courier6" --highlight=c  automaton_context.c


BACKLOG
=======
SPRINT2
- aparte de <a,b,c> introducir >a,b,c< que define concurrencia débil, puede transicionar con un subconj de estos
- implement reachability
SPRINT3
- yacc and automaton_context -> define a way to index concurrent labels, it is not the same to index particular labels (thus adding new transitions
		for each index) than to add index to concurrent labels (adding new transitions on the whole concurrent set)
- evaluation of expressions with free variables should be able to evaluate fluent valuations and constants, maybe even a random value generator with constant seed
range R = 1..2
A = ( <a, b[i:R], c[j:R]> -> A). should translate to A = ( {<a,b.1,c.1>, <a,b.2,c.1>, <a,b.1,c.2>, <a,b.2,c.2>}->A).
A = ( <a, b[i], c[i]>[i:R] -> A). should translate to A = ( {<a,b.1,c.1>, <a,b.2,c.2>}->A).
- add feedback for errors
SPRINTX
- partitioned composition, everything not on the frontier can be downloaded to a bucket list of files in order to free the memory
- keep indexes and other information in the automaton structure (concolyc style)
