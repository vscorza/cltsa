TODO:
SPRINT1
- implement gr1 use transitions instead of states since it will be easier to build strategy if last computation holds route to satisfaction
	para gr1 definir estructura de punto fijo sobre transiciones, mantiene trans_viejas, trans_agregadas, bool initialized
	el & de obdd es expandir frontera (predecesores a lo bruto)
		va de un conj de transiciones (las acumuladas) x transiciones (frontera) -> transiciones (agregadas)
	el | de obdd es una unión de transiciones, sí tenemos agregadas no hace falta revisar mucho, sólo se agregan y ya
	el cox es igual que el & pero hace predecesores que no llevan fuera de acumuladas por no controlables
	de hecho el & puede obviarse y aplicarse sólo cox ya que el & tiene sentido en sincrónico con sys y env particionado
	habría que armar un bucket list de transiciones, en base a los estados to-state	
- fluents transitions should be applied to superset of alphabet
- review and document code (particualarly compose)
- probar amba con concurrent labels
SPRINT2
- aparte de <a,b,c> introducir >a,b,c< que define concurrencia débil, puede transicionar con un subconj de estos
- parse assertions, goals
- parse safety ltl
- check compatibility with fluents when composing
- implement reachability
SPRINT3
- yacc and automaton_context -> define a way to index concurrent labels, it is not the same to index particular labels (thus adding new transitions
		for each index) than to add index to concurrent labels (adding new transitions on the whole concurrent set)
- evaluation of expressions with free variables should be able to evaluate fluent valuations and constants, maybe even a random value generator with constant seed
range R = 1..2
A = ( <a, b[i:R], c[j:R]> -> A). should translate to A = ( {<a,b.1,c.1>, <a,b.2,c.1>, <a,b.1,c.2>, <a,b.2,c.2>}->A).
A = ( <a, b[i], c[i]>[i:R] -> A). should translate to A = ( {<a,b.1,c.1>, <a,b.2,c.2>}->A).
- add feedback for errors
SPRINTX
- keep indexes and other information in the automaton structure (concolyc style)
- merge obdd and lts
