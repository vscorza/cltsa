TODO:
=====
- write documentation on this
"Te paso el lineamiento de lo que voy a escribir para el viernes, hay dos limitaciones fuertes para no presentar otro tipo de experimento para probar la adecuación de la técnica,

    no vamos a realizar un estudio controlado con sujetos que escriban y diagnostiquen especificaciones
    no hay una noción clara para comparar las técnicas existentes (minimización de fórmulas ltl) que de hecho agregan comportamiento, con nuestra técnica


Es por esto que vamos a utilizar un proxy para aproximar la calidad del recorte o minimización, la idea es utilizar el volumen (cantidad de transiciones) en comparación con la planta original. Suponiendo que E es la planta original, E' la planta minimizada y C el controlador del caso realizable vamos a presentar y analizar las relaciones |C|/|E| y |E'|/|E| donde |S| reporta la cantidad de transiciones de E.

Habrá que definir una magnitud que exprese que tan controlabe es un sistema y evaluar como se relaciona con la medida anterior. Por ejemplo |U|/|S| donde |U| expresa la cantidad de transiciones no controlables de E y |S| la cantidad de transiciones controlables."
- next deliverable
	- review konighoefer numbers
	- implement mutations on existing examples
		- remove assumption
		- add non controllable transition
		- remove controllable transition
		- mutate assumption formula using operators
		- mutate goal formula using operators
		- add conjuction of goals as new goal
	- review relation between minimization, original plant and controller either on structure or syntax
	- reason about general diagnosis 
	- diagnose mutation over small parameters, produce hypothesis, scale both hypothesis and parameter to see if it holds
- run hardware cases
	- behavior minimization based diagnosis over CLTS
	- run genbuf 2, 4, 6 clients
	- run amba 2, 4 clients (simplify as needed)
- explore controllable simplification
	- hide queue in genbuf (hide signals, tau reduction)
	- review konighoefer work
- implement formulaic labels, [!lock && !start]G2 = ( lock && start -> G2), 
	will create an automaton by initializing variables as defined in [v] and defining transitions by those who satisfhy
	rho(v, v', s, s')
- graph the way removed transitions increment in the lineal minimization
- split functionality into several files, refactor
- synthesis improvements
	- take bigger values first on synthesis
	- take noncontrollable states first on synthesis
	- keep inf scc over rankings
- compare against konighoefer and jvts systems, write experimental claim
- implement fluent consistency check
- implement IS_REALIZABLE(gr1). on parser
POST PHD
========
- develop mixed structures 
	- EROBDD (enumerative ROBDD) first node determines current state
	  s -[s1] -> s_1 | ... | s -[sk] -> s_k, the seconde node
	  (not sure if should be last one) determines next state,for each transition
	  s_i -> s_j where there are signal changes those are added, if signal
	  v is set between s_i,s_j then v is false in V and true in V',
	  recreate this o EROBDD s_i, s' branch, then the EROBDD is minimized, first
	  as OBDDs then, for equivalent state nodes, merges are represented as 
	  intervals S_{1,4,[7,12]} and so on
	- define apply:EROBDD x OBDD -> EROBDD (where an OBDD is restricted by
	  an EROBDD)
	- define EROBDD valuations
	- write definitions and lemmas
	- implement and test against existing examples
- [automata-reporter]
	- integration of cfsp editor (parsing error location info)
	- partial automaton exploration for big automata (jung adaptation with outgoing dashed labels)
	- alla RATSY signal reporting for automaton
- document obdd
- adapt examples from https://www.doulos.com/knowhow/psl/
- solve aliases in states e.g. S[i:R] = S_p[i], S_p[i:R] = (s->S_2[i]).
- implement relabeling and hiding (use half adder to full adder example)
- implement symbolic synthesis
- implement diagnosis of maximal realizable ltl spec (maximal set of ltl formula s.t. at least one liveness is satisfied)

Meetings
========
2019-10-16 meeting
- How does CLTS control problem compares to LTS cp? Does every CLTS control problem can be encoded as LTS?
- Where is the benefit when solving hardware specs? Is it in the formalism or the tool?
- What happens with the language of the composition? does the components languages are included in the target?
- Explain the motivation behind the availability of two composition semantics, motivate it as allowing encapsulation of synch component asynchronous composed with another (or viceversa)


PRINT CODE
==========
enscript -2r -T=1 --line-numbers -p out.ps --font="Courier6" --highlight=c  automaton_context.c


BACKLOG
=======
SPRINT2
- aparte de <a,b,c> introducir >a,b,c< que define concurrencia débil, puede transicionar con un subconj de estos
- implement reachability
SPRINT3
- yacc and automaton_context -> define a way to index concurrent labels, it is not the same to index particular labels (thus adding new transitions
		for each index) than to add index to concurrent labels (adding new transitions on the whole concurrent set)
- evaluation of expressions with free variables should be able to evaluate fluent valuations and constants, maybe even a random value generator with constant seed
range R = 1..2
A = ( <a, b[i:R], c[j:R]> -> A). should translate to A = ( {<a,b.1,c.1>, <a,b.2,c.1>, <a,b.1,c.2>, <a,b.2,c.2>}->A).
A = ( <a, b[i], c[i]>[i:R] -> A). should translate to A = ( {<a,b.1,c.1>, <a,b.2,c.2>}->A).
- add feedback for errors
SPRINTX
- partitioned composition, everything not on the frontier can be downloaded to a bucket list of files in order to free the memory
- keep indexes and other information in the automaton structure (concolyc style)
