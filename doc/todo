TODO:
=====
- write behavior minimization cases in clts
- change transitions to | to_state | is_input | bit_array of signals |
- run hardware cases
	- behavior minimization based diagnosis over CLTS
	- diagnose GENBUF with 2 clients
	- run genbuf 2, 4, 10 clients
	- run amba 2, 4, 10 clients
- explore controllable simplification
	- hide queue in genbuf (hide signals, tau reduction)
	- review konighoefer work
- graph the way removed transitions increment in the lineal minimization
- split functionality into several files, refactor
- synthesis improvements
	- take bigger values first on synthesis
	- take noncontrollable states first on synthesis
	- keep inf scc over rankings
- compare against konighoefer and jvts systems, write experimental claim
- implement fluent consistency check
- implement IS_REALIZABLE(gr1). on parser
- develop mixed structures 
	- EROBDD (enumerative ROBDD) first node determines current state
	  s -[s1] -> s_1 | ... | s -[sk] -> s_k, the seconde node
	  (not sure if should be last one) determines next state,for each transition
	  s_i -> s_j where there are signal changes those are added, if signal
	  v is set between s_i,s_j then v is false in V and true in V',
	  recreate this o EROBDD s_i, s' branch, then the EROBDD is minimized, first
	  as OBDDs then, for equivalent state nodes, merges are represented as 
	  intervals S_{1,4,[7,12]} and so on
	- define apply:EROBDD x OBDD -> EROBDD (where an OBDD is restricted by
	  an EROBDD)
	- define EROBDD valuations
	- write definitions and lemmas
	- implement and test against existing examples
- [automata-reporter]
	- integration of cfsp editor (parsing error location info)
	- partial automaton exploration for big automata (jung adaptation with outgoing dashed labels)
	- alla RATSY signal reporting for automaton
- document obdd
- adapt examples from https://www.doulos.com/knowhow/psl/
- solve aliases in states e.g. S[i:R] = S_p[i], S_p[i:R] = (s->S_2[i]).
- implement relabeling and hiding (use half adder to full adder example)
- implement symbolic synthesis
- implement diagnosis of maximal realizable ltl spec (maximal set of ltl formula s.t. at least one liveness is satisfied)

Meetings
========
2019-10-16 meeting
- How does CLTS control problem compares to LTS cp? Does every CLTS control problem can be encoded as LTS?
- Where is the benefit when solving hardware specs? Is it in the formalism or the tool?
- What happens with the language of the composition? does the components languages are included in the target?
- Explain the motivation behind the availability of two composition semantics, motivate it as allowing encapsulation of synch component asynchronous composed with another (or viceversa)


PRINT CODE
==========
enscript -2r -T=1 --line-numbers -p out.ps --font="Courier6" --highlight=c  automaton_context.c


BACKLOG
=======
SPRINT2
- aparte de <a,b,c> introducir >a,b,c< que define concurrencia dÃ©bil, puede transicionar con un subconj de estos
- parse assertions, goals
- implement reachability
SPRINT3
- yacc and automaton_context -> define a way to index concurrent labels, it is not the same to index particular labels (thus adding new transitions
		for each index) than to add index to concurrent labels (adding new transitions on the whole concurrent set)
- evaluation of expressions with free variables should be able to evaluate fluent valuations and constants, maybe even a random value generator with constant seed
range R = 1..2
A = ( <a, b[i:R], c[j:R]> -> A). should translate to A = ( {<a,b.1,c.1>, <a,b.2,c.1>, <a,b.1,c.2>, <a,b.2,c.2>}->A).
A = ( <a, b[i], c[i]>[i:R] -> A). should translate to A = ( {<a,b.1,c.1>, <a,b.2,c.2>}->A).
- add feedback for errors
SPRINTX
- partitioned composition, everything not on the frontier can be downloaded to a bucket list of files in order to free the memory
- keep indexes and other information in the automaton structure (concolyc style)
- merge obdd and lts
